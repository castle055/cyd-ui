.TH "src/graphics/x11/render/render.cpp" 3 "CYD-UI" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/graphics/x11/render/render.cpp
.SH SYNOPSIS
.br
.PP
\fC#include '\&.\&./state/state\&.hpp'\fP
.br
\fC#include 'render\&.hpp'\fP
.br
\fC#include 'cydstd/logging\&.hpp'\fP
.br
\fC#include <X11/Xlib\&.h>\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBxcolor_hot_cache_entry_t\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBrender_sbr\fP (\fBcydui::graphics::window_t\fP *win, XImage *image)"
.br
.ti -1c
.RI "void \fBrender_task\fP (\fBcydui::threading::thread_t\fP *this_thread)"
.br
.ti -1c
.RI "XColor \fBcolor_to_xcolor\fP (\fBcolor::Color\fP color)"
.br
.ti -1c
.RI "XftColor * \fBcolor_to_xftcolor\fP (\fBcolor::Color\fP color)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBlogging::logger\fP \fBxlog_ctrl\fP = {\&.name = 'X11::RENDER::CTRL', \&.on = false}"
.br
.ti -1c
.RI "\fBlogging::logger\fP \fBxlog_task\fP = {\&.name = 'X11::RENDER::TASK', \&.on = true}"
.br
.ti -1c
.RI "static std::mutex \fBx_mtx\fP {}"
.br
.ti -1c
.RI "static std::unordered_map< \fBu32\fP, XColor > \fBxcolor_cache\fP"
.br
.ti -1c
.RI "static constexpr \fBu32\fP \fBxcolor_hot_cache_size\fP = 8"
.br
.ti -1c
.RI "static \fBxcolor_hot_cache_entry_t\fP \fBxcolor_hot_cache\fP [\fBxcolor_hot_cache_size\fP]"
.br
.ti -1c
.RI "static \fBu32\fP \fBxcolor_hot_cache_current_insert_index\fP = 0U"
.br
.ti -1c
.RI "static std::unordered_map< \fBu32\fP, XftColor * > \fBxftcolor_cache\fP"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "XColor color_to_xcolor (\fBcolor::Color\fP color)"

.PP
Definition at line \fB102\fP of file \fBrender\&.cpp\fP\&..PP
.nf
102                                          {
103   u32 color_id = color\&.to_id();
104   
105   for (auto &entry: xcolor_hot_cache) {
106     if (entry\&.id == color_id) {
107       return entry\&.xcolor;
108     }
109   }
110   
111   if (xcolor_cache\&.contains(color_id)) {
112     auto &c = xcolor_cache[color_id];
113     xcolor_hot_cache[xcolor_hot_cache_current_insert_index++] = {
114       \&.id = color_id,
115       \&.xcolor = c,
116     };
117     if (xcolor_hot_cache_current_insert_index >= xcolor_hot_cache_size) {
118       xcolor_hot_cache_current_insert_index = 0U;
119     }
120     return c;
121   }
122   
123   auto dpy = state::get_dpy();
124   auto screen = state::get_screen();
125   Colormap map = DefaultColormap(dpy, screen);
126   XColor c;
127   XParseColor(dpy, map, color\&.to_string()\&.c_str(), &c);
128   XAllocColor(dpy, map, &c);
129   
130   xcolor_hot_cache[xcolor_hot_cache_current_insert_index++] = {
131     \&.id = color_id,
132     \&.xcolor = c,
133   };
134   if (xcolor_hot_cache_current_insert_index >= xcolor_hot_cache_size) {
135     xcolor_hot_cache_current_insert_index = 0U;
136   }
137   
138   xcolor_cache[color_id] = c;
139   return c;
140 }
.fi

.SS "XftColor * color_to_xftcolor (\fBcolor::Color\fP color)"

.PP
Definition at line \fB144\fP of file \fBrender\&.cpp\fP\&..PP
.nf
144                                               {
145   u32 color_id = color\&.to_id();
146   if (xftcolor_cache\&.contains(color_id))
147     return xftcolor_cache[color_id];
148   
149   auto* c = new XftColor;
150   
151   auto dpy = state::get_dpy();
152   auto screen = state::get_screen();
153   if (!XftColorAllocName(dpy,
154     DefaultVisual(dpy, screen),
155     DefaultColormap(dpy, screen),
156     color\&.to_string()\&.c_str(),
157     c)) {
158     xlog_ctrl\&.error("Cannot allocate color %s", color\&.to_string()\&.c_str());
159   }
160   
161   xftcolor_cache[color_id] = c;
162   return c;
163 }
.fi

.SS "void render_sbr (\fBcydui::graphics::window_t\fP * win, XImage * image)"

.PP
Definition at line \fB18\fP of file \fBrender\&.cpp\fP\&..PP
.nf
18                                                            {
19   //window_render_req req;
20   
21   //win\->render_mtx\&.lock();
22   //bool dirty = win\->dirty;
23   //win\->dirty = false;
24   //win\->render_mtx\&.unlock();
25   //
26   //if (!dirty)
27   //  return;
28   
29   win\->render_mtx\&.lock();
30   {
31     image\->depth = 32;//DisplayPlanes(state::get_dpy(), state::get_screen());
32     image\->format = ZPixmap;
33     image\->xoffset = 0;
34     image\->data = (char*) win\->render_target\->data;
35     image\->width = win\->render_target\->width();
36     image\->height = win\->render_target\->height();
37     image\->bitmap_pad = 32;
38     image\->bitmap_unit = 32;
39     image\->bits_per_pixel = 32;
40     image\->bytes_per_line = (int) win\->render_target\->width() * 4;
41     if (0 != XInitImage(image)
42       && win\->gc) {
43       //if (x_mtx\&.try_lock()) {
44       auto _pev = win\->profiler\->scope_event("render::render_sbr");
45       //win\->x_mtx\&.lock();
46       XPutImage(state::get_dpy(),
47         win\->xwin,
48         win\->gc,
49         image,
50         0, 0,
51         0, 0,
52         win\->render_target\->width(), win\->render_target\->height()
53       );
54       //x_mtx\&.unlock();
55       //}
56       //X Flush(state::get_dpy());
57       
58       //XDestroyImage(image);
59     }
60   }
61   win\->render_mtx\&.unlock();
62   //win\->x_mtx\&.unlock();
63 }
.fi

.SS "void render_task (\fBcydui::threading::thread_t\fP * this_thread)"

.PP
Definition at line \fB67\fP of file \fBrender\&.cpp\fP\&..PP
.nf
67                                                       {
68   xlog_task\&.debug("Started render thread");
69   auto* render_data = (render::RenderThreadData*) this_thread\->data;
70   auto t0 = std::chrono::system_clock::now();
71   while (this_thread\->running) {
72     t0 = std::chrono::system_clock::now();
73     render_sbr(render_data\->win, render_data\->image);
74     //std::this_thread::sleep_until(t0 + 16666us); // 60 FPS
75     std::this_thread::sleep_until(t0 + 2 * 16666us); // 30 FPS
76   }
77 }
.fi

.SH "Variable Documentation"
.PP 
.SS "std::mutex x_mtx {}\fC [static]\fP"

.PP
Definition at line \fB16\fP of file \fBrender\&.cpp\fP\&..PP
.nf
16 {};
.fi

.SS "std::unordered_map<\fBu32\fP, XColor> xcolor_cache\fC [static]\fP"

.PP
Definition at line \fB92\fP of file \fBrender\&.cpp\fP\&.
.SS "\fBxcolor_hot_cache_entry_t\fP xcolor_hot_cache[\fBxcolor_hot_cache_size\fP]\fC [static]\fP"

.PP
Definition at line \fB99\fP of file \fBrender\&.cpp\fP\&.
.SS "\fBu32\fP xcolor_hot_cache_current_insert_index = 0U\fC [static]\fP"

.PP
Definition at line \fB100\fP of file \fBrender\&.cpp\fP\&.
.SS "constexpr \fBu32\fP xcolor_hot_cache_size = 8\fC [static]\fP, \fC [constexpr]\fP"

.PP
Definition at line \fB98\fP of file \fBrender\&.cpp\fP\&.
.SS "std::unordered_map<\fBu32\fP, XftColor*> xftcolor_cache\fC [static]\fP"

.PP
Definition at line \fB142\fP of file \fBrender\&.cpp\fP\&.
.SS "\fBlogging::logger\fP xlog_ctrl = {\&.name = 'X11::RENDER::CTRL', \&.on = false}"

.PP
Definition at line \fB13\fP of file \fBrender\&.cpp\fP\&..PP
.nf
13 {\&.name = "X11::RENDER::CTRL", \&.on = false};
.fi

.SS "\fBlogging::logger\fP xlog_task = {\&.name = 'X11::RENDER::TASK', \&.on = true}"

.PP
Definition at line \fB14\fP of file \fBrender\&.cpp\fP\&..PP
.nf
14 {\&.name = "X11::RENDER::TASK", \&.on = true};
.fi

.SH "Author"
.PP 
Generated automatically by Doxygen for CYD-UI from the source code\&.
