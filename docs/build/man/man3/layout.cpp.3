.TH "src/layout/layout.cpp" 3 "CYD-UI" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/layout/layout.cpp
.SH SYNOPSIS
.br
.PP
\fC#include 'core/layout\&.h'\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBCOMPUTE\fP(DIM)"
.br
.ti -1c
.RI "#define \fBINSTANCE_EV_HANDLER\fP(STATE_PTR)"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "static bool \fBcompute_dimensions\fP (\fBcomponent_base_t\fP *rt)"
.br
.ti -1c
.RI "static \fBevent_handler_t\fP * \fBget_instance_ev_handler\fP (\fBcomponent_state_t\fP *component_state)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBlogging::logger\fP \fBlog_lay\fP"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define COMPUTE(DIM)"
\fBValue:\fP.PP
.nf
  if (!dimension_t::compute(DIM)) {                                            \\
    return false;                                                              \\
  }
.fi

.PP
Definition at line \fB10\fP of file \fBlayout\&.cpp\fP\&..PP
.nf
11                                 {                                            \\
12     return false;                                                              \\
13   }
.fi

.SS "#define INSTANCE_EV_HANDLER(STATE_PTR)"
\fBValue:\fP.PP
.nf
  if (STATE_PTR\->component_instance\&.has_value()) \\
    STATE_PTR\->component_instance\&.value()\->event_handler()
.fi

.PP
Definition at line \fB161\fP of file \fBlayout\&.cpp\fP\&.
.SH "Function Documentation"
.PP 
.SS "static bool compute_dimensions (\fBcomponent_base_t\fP * rt)\fC [static]\fP"
COMPUTE SOME VALUES
.PP
COMPUTE CHILDREN ORIGIN POINT (cx, cy)
.PP
COMPUTE SIZE
.PP
COMPUTE DIMENSIONS FOR CHILDREN RECURSIVELY
.PP
Definition at line \fB18\fP of file \fBlayout\&.cpp\fP\&..PP
.nf
18                                                      {
19   using namespace cydui::dimensions;
20   component_dimensional_relations_t dim = rt\->get_dimensional_relations();
21   
23   COMPUTE(dim\&.x)
24   COMPUTE(dim\&.y)
25   
26   COMPUTE(dim\&.margin_top)
27   COMPUTE(dim\&.margin_right)
28   COMPUTE(dim\&.margin_bottom)
29   COMPUTE(dim\&.margin_left)
30   
31   COMPUTE(dim\&.padding_top)
32   COMPUTE(dim\&.padding_right)
33   COMPUTE(dim\&.padding_bottom)
34   COMPUTE(dim\&.padding_left)
35   
37   if (rt\->parent\&.has_value()) {
38     component_dimensional_relations_t parent_dim = rt\->parent\&.value()\->get_dimensional_relations();
39     dim\&.cx = parent_dim\&.cx\&.val()
40       + dim\&.x\&.val()
41       + dim\&.margin_left\&.val()
42       + dim\&.padding_left\&.val();
43     dim\&.cy = parent_dim\&.cy\&.val()
44       + dim\&.y\&.val()
45       + dim\&.margin_top\&.val()
46       + dim\&.padding_top\&.val();
47   } else {
48     dim\&.cx = dim\&.x\&.val() + dim\&.margin_left\&.val() + dim\&.padding_left\&.val();
49     dim\&.cy = dim\&.y\&.val() + dim\&.margin_top\&.val() + dim\&.padding_top\&.val();
50   }
51   
53   if (!dim\&.fixed_w) {
54     dim\&.w\&.unknown = true;
55   } else {
56     COMPUTE(dim\&.w)
57     dim\&.cw = dim\&.w\&.val() \- dim\&.padding_left\&.val() \- dim\&.padding_right\&.val()
58       \- dim\&.margin_left\&.val() \- dim\&.margin_right\&.val();
59   }
60   if (!dim\&.fixed_h) {
61     dim\&.h\&.unknown = true;
62   } else {
63     COMPUTE(dim\&.h)
64     dim\&.ch = dim\&.h\&.val() \- dim\&.padding_top\&.val() \- dim\&.padding_bottom\&.val()
65       \- dim\&.margin_top\&.val() \- dim\&.margin_bottom\&.val();
66   }
67   
69   std::vector<component_base_t*> pending;
70   
71   dimension_value_t total_w = 0;
72   dimension_value_t total_h = 0;
73   for (auto &child: rt\->children) {
74     //compute_dimensions(child);
75     // if error (circular dependency), skip for now, and then recalculate
76     if (compute_dimensions(child)) {
77       component_dimensional_relations_t c_dim = child\->get_dimensional_relations();
78       dimension_value_t child_max_w = c_dim\&.x\&.val() + c_dim\&.w\&.val();
79       dimension_value_t child_max_h = c_dim\&.y\&.val() + c_dim\&.h\&.val();
80       total_w = std::max(total_w, child_max_w);
81       total_h = std::max(total_h, child_max_h);
82     } else {
83       pending\&.push_back(child);
84     }
85   }
86   
87   if (!dim\&.fixed_w) {// If not given, or given has error (ie: circular dep)
88     dim\&.cw = total_w;
89     dim\&.w = dim\&.cw\&.val() + dim\&.padding_left\&.val() + dim\&.padding_right\&.val()
90       + dim\&.margin_left\&.val() + dim\&.margin_right\&.val();
91   }
92   
93   if (!dim\&.fixed_h) {// If not given, or given has error (ie: circular dep)
94     dim\&.ch = total_h;
95     dim\&.h = dim\&.ch\&.val() + dim\&.padding_top\&.val() + dim\&.padding_bottom\&.val()
96       + dim\&.margin_top\&.val() + dim\&.margin_bottom\&.val();
97   }
98   
99   return std::all_of(pending\&.begin(), pending\&.end(), compute_dimensions);
100 }
.fi

.SS "static \fBevent_handler_t\fP * get_instance_ev_handler (\fBcomponent_state_t\fP * component_state)\fC [static]\fP"

.PP
Definition at line \fB157\fP of file \fBlayout\&.cpp\fP\&..PP
.nf
157                                                                                     {
158 
159 }
.fi

.SH "Variable Documentation"
.PP 
.SS "\fBlogging::logger\fP log_lay"
\fBInitial value:\fP.PP
.nf
= {
  \&.name = "LAYOUT", \&.on = true, \&.min_level = logging::INFO}
.fi

.PP
Definition at line \fB7\fP of file \fBlayout\&.cpp\fP\&..PP
.nf
7                         {
8   \&.name = "LAYOUT", \&.on = true, \&.min_level = logging::INFO};
.fi

.SH "Author"
.PP 
Generated automatically by Doxygen for CYD-UI from the source code\&.
