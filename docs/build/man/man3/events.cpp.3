.TH "src/graphics/x11/events/events.cpp" 3 "CYD-UI" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/graphics/x11/events/events.cpp
.SH SYNOPSIS
.br
.PP
\fC#include 'events\&.hpp'\fP
.br
\fC#include 'cydstd/logging\&.hpp'\fP
.br
\fC#include '\&.\&./state/state\&.hpp'\fP
.br
\fC#include <X11/Xlib\&.h>\fP
.br
\fC#include <X11/keysym\&.h>\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "Bool \fBevpredicate\fP ()"
.br
.ti -1c
.RI "static void \fBrun\fP ()"
.br
.ti -1c
.RI "void \fBx11_event_emitter_task\fP (\fBcydui::threading::thread_t\fP *this_thread)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBcydui::threading::thread_t\fP * \fBx11_thread\fP"
.br
.ti -1c
.RI "\fBlogging::logger\fP \fBx11_evlog\fP = {\&.name = 'X11::EV'}"
.br
.ti -1c
.RI "\fBlogging::logger\fP \fBchev_log\fP = {\&.name = 'EV::CHANGE', \&.on = false}"
.br
.ti -1c
.RI "\fBcydui::events::change_ev::DataMonitor\fP< \fBRedrawEvent\fP > \fBredrawEventDataMonitor\fP ([](\fBRedrawEvent::DataType\fP &o_data, \fBRedrawEvent::DataType\fP &n_data) { return true;})"
.br
.ti -1c
.RI "\fBcydui::events::change_ev::DataMonitor\fP< \fBResizeEvent\fP > \fBresizeEventDataMonitor\fP ([](\fBResizeEvent::DataType\fP &o_data, \fBResizeEvent::DataType\fP &n_data) { return(o_data\&.w !=n_data\&.w||o_data\&.h !=n_data\&.h);})"
.br
.ti -1c
.RI "\fBcydui::events::change_ev::DataMonitor\fP< \fBMotionEvent\fP > \fBmotionEventDataMonitor\fP ([](\fBMotionEvent::DataType\fP &o_data, \fBMotionEvent::DataType\fP &n_data) { return true;})"
.br
.ti -1c
.RI "\fBcydui::events::change_ev::DataMonitor\fP< \fBScrollEvent\fP > \fBvScrollEventDataMonitor\fP ([](\fBScrollEvent::DataType\fP &o_data, \fBScrollEvent::DataType\fP &n_data) { n_data\&.dy+=o_data\&.dy;return true;}, [](\fBScrollEvent::DataType\fP &data) { data\&.dy=0;})"
.br
.RI "This prevents the event thread from chocking on scroll events\&. "
.ti -1c
.RI "\fBcydui::events::change_ev::DataMonitor\fP< \fBScrollEvent\fP > \fBhScrollEventDataMonitor\fP ([](\fBScrollEvent::DataType\fP &o_data, \fBScrollEvent::DataType\fP &n_data) { n_data\&.dx+=o_data\&.dx;return true;}, [](\fBScrollEvent::DataType\fP &data) { data\&.dx=0;})"
.br
.RI "This prevents the event thread from chocking on scroll events\&. "
.ti -1c
.RI "static std::unordered_map< KeySym, \fBKey\fP > \fBxkey_map\fP"
.br
.ti -1c
.RI "char \fBinput_buffer\fP [10]"
.br
.ti -1c
.RI "static XIM \fBxim\fP"
.br
.ti -1c
.RI "static XIC \fBxic\fP"
.br
.ti -1c
.RI "Status \fBst\fP"
.br
.ti -1c
.RI "KeySym \fBksym\fP"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "Bool evpredicate ()"

.PP
Definition at line \fB19\fP of file \fBevents\&.cpp\fP\&..PP
.nf
19                    {
20   return True;
21 }
.fi

.SS "static void run ()\fC [static]\fP"
I give no chance for this event not to be emitted
.PP
Definition at line \fB119\fP of file \fBevents\&.cpp\fP\&..PP
.nf
119                   {
120   XEvent ev;
121   
122   int queued = XEventsQueued(state::get_dpy(), QueuedAlready);
123   for (int i = 0; i < queued; ++i) {
124     XNextEvent(
125       state::get_dpy(),
126       &ev
127     );
128     //if (6 != ev\&.type
129     //  && 2 != ev\&.type
130     //  && 3 != ev\&.type
131     //  )
132     //x11_evlog\&.debug("event = %d", ev\&.type);
133     using namespace cydui::events;
134     switch (ev\&.type) {
135       case MapNotify:
136         break;
137       case VisibilityNotify:
138       case Expose:
139         if (ev\&.xvisibility\&.type == VisibilityNotify) {
140           redrawEventDataMonitor\&.update({
141             \&.win = (unsigned int) ev\&.xvisibility\&.window,
142           });
143         } else if (ev\&.xexpose\&.type == Expose
144           && ev\&.xexpose\&.count == 0
145           /*&& ev\&.xexpose\&.width > 0
146           && ev\&.xexpose\&.height > 0*/) {
147           redrawEventDataMonitor\&.update({
148             \&.win = (unsigned int) ev\&.xexpose\&.window,
149           });
150         }
151         break;
152       case KeyPress://x11_evlog\&.warn("KEY= %X", XLookupKeysym(&ev\&.xkey, 0));
153         Xutf8LookupString(xic, &ev\&.xkey, input_buffer, 10, &ksym, &st);
154         //x11_evlog\&.warn("BUF(%d)= %s", st, input_buffer);
155         if ((st == XLookupKeySym || st == XLookupBoth)) {
156           //x11_evlog\&.warn("====FOUND");
157           emit<KeyEvent>({
158             \&.win = (unsigned int) ev\&.xkey\&.window,
159             \&.key = xkey_map\&.contains(ksym) ? xkey_map[ksym] : Key::UNKNOWN,
160             \&.pressed = true,
161             \&.text = st == XLookupBoth ? str(input_buffer) : "",
162           });
163         }
164         break;
165       case KeyRelease:
166         if (xkey_map\&.contains(XLookupKeysym(&ev\&.xkey, 0))) {
167           emit<KeyEvent>({
168             \&.win = (unsigned int) ev\&.xkey\&.window,
169             \&.key = xkey_map[XLookupKeysym(&ev\&.xkey, 0)],
170             \&.released = true,
171           });
172         }
173         break;
174       case ButtonPress:
175         //x11_evlog\&.warn("BUTTON= %d", ev\&.xbutton\&.button);
176         if (ev\&.xbutton\&.button == 4) {
177           //emit<ScrollEvent>({
178           //  \&.win = (unsigned int) ev\&.xbutton\&.window,
179           //  \&.dy = 64,
180           //  \&.x = ev\&.xbutton\&.x,
181           //  \&.y = ev\&.xbutton\&.y,
182           //});
183           vScrollEventDataMonitor\&.update({
184             \&.win = (unsigned int) ev\&.xbutton\&.window,
185             \&.dy = 64,
186             \&.x = ev\&.xbutton\&.x,
187             \&.y = ev\&.xbutton\&.y,
188           });
189         } else if (ev\&.xbutton\&.button == 5) {
190           //emit<ScrollEvent>({
191           //  \&.win = (unsigned int) ev\&.xbutton\&.window,
192           //  \&.dy = \-64,
193           //  \&.x = ev\&.xbutton\&.x,
194           //  \&.y = ev\&.xbutton\&.y,
195           //});
196           vScrollEventDataMonitor\&.update({
197             \&.win = (unsigned int) ev\&.xbutton\&.window,
198             \&.dy = \-64,
199             \&.x = ev\&.xbutton\&.x,
200             \&.y = ev\&.xbutton\&.y,
201           });
202         } else if (ev\&.xbutton\&.button == 6) {
203           hScrollEventDataMonitor\&.update({
204             \&.win = (unsigned int) ev\&.xbutton\&.window,
205             \&.dx = \-64,
206             \&.x = ev\&.xbutton\&.x,
207             \&.y = ev\&.xbutton\&.y,
208           });
209         } else if (ev\&.xbutton\&.button == 7) {
210           hScrollEventDataMonitor\&.update({
211             \&.win = (unsigned int) ev\&.xbutton\&.window,
212             \&.dx = 64,
213             \&.x = ev\&.xbutton\&.x,
214             \&.y = ev\&.xbutton\&.y,
215           });
216         } else {
217           emit<ButtonEvent>({
218             \&.win = (unsigned int) ev\&.xbutton\&.window,
219             \&.button = ev\&.xbutton\&.button,
220             \&.x      = ev\&.xbutton\&.x,
221             \&.y      = ev\&.xbutton\&.y,
222             \&.pressed = true,
223           });
224         }
225         break;
226       case ButtonRelease:
227         if (4 != ev\&.xbutton\&.button
228           && 5 != ev\&.xbutton\&.button
229           && 6 != ev\&.xbutton\&.button
230           && 7 != ev\&.xbutton\&.button
231           ) {
232           emit<ButtonEvent>({
233             \&.win = (unsigned int) ev\&.xbutton\&.window,
234             \&.button = ev\&.xbutton\&.button,
235             \&.x      = ev\&.xbutton\&.x,
236             \&.y      = ev\&.xbutton\&.y,
237             \&.released = true,
238           });
239         }
240         break;
241       case MotionNotify://x11_evlog\&.info("%d\-%d", ev\&.xmotion\&.x, ev\&.xmotion\&.y);
242         //x11_evlog\&.warn("%lX \- MOTION", ev\&.xmotion\&.window);
243         motionEventDataMonitor\&.update({
244           \&.win = (unsigned int) ev\&.xmotion\&.window,
245           \&.x = ev\&.xmotion\&.x,
246           \&.y = ev\&.xmotion\&.y,
247           \&.dragging = (ev\&.xmotion\&.state & Button1Mask) > 0,
248         });
249         break;
250       case ConfigureNotify://x11_evlog\&.info("%d\-%d", ev\&.xconfigure\&.width, ev\&.xconfigure\&.height);
251         resizeEventDataMonitor\&.update({
252           \&.win = (unsigned int) ev\&.xconfigure\&.window,
253           \&.w = ev\&.xconfigure\&.width,
254           \&.h = ev\&.xconfigure\&.height,
255         });
256         break;
257       case EnterNotify:
258         break;
259       case LeaveNotify:
261         emit<MotionEvent>({
262           \&.win = (unsigned int) ev\&.xcrossing\&.window,
263           \&.x = \-1,
264           \&.y = \-1,
265         });
266         redrawEventDataMonitor\&.update({
267           \&.win = (unsigned int) ev\&.xcrossing\&.window,
268         });
269         break;
270       case FocusIn:
271         //x11_evlog\&.error("%lX \- FOCUS IN", ev\&.xfocus\&.window);
272         break;
273       case FocusOut:
274         //x11_evlog\&.error("%lX \- FOCUS OUT", ev\&.xfocus\&.window);
275         break;
276       case KeymapNotify:
277       case CreateNotify:
278       case DestroyNotify:
279       case UnmapNotify:
280       case ResizeRequest:
281       case MapRequest:
282       case ReparentNotify:
283       case ConfigureRequest:
284       case GravityNotify:
285       case CirculateNotify:
286       case CirculateRequest:
287       case PropertyNotify:
288       case SelectionClear:
289       case SelectionRequest:
290       case SelectionNotify:
291       case ColormapNotify:
292       case ClientMessage:
293       case MappingNotify:
294       case GenericEvent:
295       default:
296         break;
297     }
298   }
299   XFlush(state::get_dpy());
300 }
.fi

.SS "void x11_event_emitter_task (\fBcydui::threading::thread_t\fP * this_thread)"

.PP
Definition at line \fB304\fP of file \fBevents\&.cpp\fP\&..PP
.nf
304                                                                  {
305   xim = XOpenIM(state::get_dpy(), NULL, NULL, NULL);
306   xic = XCreateIC(xim,
307     XNInputStyle, XIMPreeditNothing | XIMStatusNothing,
308     NULL
309   );
310   while (this_thread\->running) {
311     run();
312     std::this_thread::sleep_for(20ms);
313   }
314   XDestroyIC(xic);
315   XCloseIM(xim);
316 }
.fi

.SH "Variable Documentation"
.PP 
.SS "\fBlogging::logger\fP chev_log = {\&.name = 'EV::CHANGE', \&.on = false}"

.PP
Definition at line \fB14\fP of file \fBevents\&.cpp\fP\&..PP
.nf
14 {\&.name = "EV::CHANGE", \&.on = false};
.fi

.SS "\fBcydui::events::change_ev::DataMonitor\fP< \fBScrollEvent\fP > hScrollEventDataMonitor([](\fBScrollEvent::DataType\fP &o_data, \fBScrollEvent::DataType\fP &n_data) { n_data\&.dx+=o_data\&.dx;return true;},[](\fBScrollEvent::DataType\fP &data) { data\&.dx=0;}) ([] (\fBScrollEvent::DataType\fP &o_data, \fBScrollEvent::DataType\fP &n_data) { n_data\&.dx+=o_data\&.dx;return true;}, [] (\fBScrollEvent::DataType\fP &data) { data\&.dx=0;})"

.PP
This prevents the event thread from chocking on scroll events\&. 
.PP
\fBNote\fP
.RS 4
It does impose a limit on the scroll speed to 64 units per frame in either direction 
.RE
.PP

.SS "char input_buffer[10]"

.PP
Definition at line \fB113\fP of file \fBevents\&.cpp\fP\&.
.SS "KeySym ksym"

.PP
Definition at line \fB117\fP of file \fBevents\&.cpp\fP\&.
.SS "\fBcydui::events::change_ev::DataMonitor\fP< \fBMotionEvent\fP > motionEventDataMonitor([](\fBMotionEvent::DataType\fP &o_data, \fBMotionEvent::DataType\fP &n_data) { return true;}) ([] (\fBMotionEvent::DataType\fP &o_data, \fBMotionEvent::DataType\fP &n_data) { return true;})"

.SS "\fBcydui::events::change_ev::DataMonitor\fP< \fBRedrawEvent\fP > redrawEventDataMonitor([](\fBRedrawEvent::DataType\fP &o_data, \fBRedrawEvent::DataType\fP &n_data) { return true;}) ([] (\fBRedrawEvent::DataType\fP &o_data, \fBRedrawEvent::DataType\fP &n_data) { return true;})"

.SS "\fBcydui::events::change_ev::DataMonitor\fP< \fBResizeEvent\fP > resizeEventDataMonitor([](\fBResizeEvent::DataType\fP &o_data, \fBResizeEvent::DataType\fP &n_data) { return(o_data\&.w !=n_data\&.w||o_data\&.h !=n_data\&.h); }) ([] (\fBResizeEvent::DataType\fP &o_data, \fBResizeEvent::DataType\fP &n_data) { return(o_data\&.w !=n_data\&.w||o_data\&.h !=n_data\&.h);})"

.SS "Status st"

.PP
Definition at line \fB116\fP of file \fBevents\&.cpp\fP\&.
.SS "\fBcydui::events::change_ev::DataMonitor\fP< \fBScrollEvent\fP > vScrollEventDataMonitor([](\fBScrollEvent::DataType\fP &o_data, \fBScrollEvent::DataType\fP &n_data) { n_data\&.dy+=o_data\&.dy;return true;},[](\fBScrollEvent::DataType\fP &data) { data\&.dy=0;}) ([] (\fBScrollEvent::DataType\fP &o_data, \fBScrollEvent::DataType\fP &n_data) { n_data\&.dy+=o_data\&.dy;return true;}, [] (\fBScrollEvent::DataType\fP &data) { data\&.dy=0;})"

.PP
This prevents the event thread from chocking on scroll events\&. 
.PP
\fBNote\fP
.RS 4
It does impose a limit on the scroll speed to 64 units per frame in either direction 
.RE
.PP

.SS "\fBlogging::logger\fP x11_evlog = {\&.name = 'X11::EV'}"

.PP
Definition at line \fB13\fP of file \fBevents\&.cpp\fP\&..PP
.nf
13 {\&.name = "X11::EV"};
.fi

.SS "\fBcydui::threading::thread_t\fP* x11_thread"

.PP
Definition at line \fB11\fP of file \fBevents\&.cpp\fP\&.
.SS "XIC xic\fC [static]\fP"

.PP
Definition at line \fB115\fP of file \fBevents\&.cpp\fP\&.
.SS "XIM xim\fC [static]\fP"

.PP
Definition at line \fB114\fP of file \fBevents\&.cpp\fP\&.
.SS "std::unordered_map<KeySym, \fBKey\fP> xkey_map\fC [static]\fP"

.PP
Definition at line \fB67\fP of file \fBevents\&.cpp\fP\&..PP
.nf
67                                                  {
68   {XK_a, Key::A},
69   {XK_b, Key::B},
70   {XK_c, Key::C},
71   {XK_d, Key::D},
72   {XK_e, Key::E},
73   {XK_f, Key::F},
74   {XK_g, Key::G},
75   {XK_h, Key::H},
76   {XK_i, Key::I},
77   {XK_j, Key::J},
78   {XK_k, Key::K},
79   {XK_l, Key::L},
80   {XK_m, Key::M},
81   {XK_n, Key::N},
82   {XK_o, Key::O},
83   {XK_p, Key::P},
84   {XK_q, Key::Q},
85   {XK_r, Key::R},
86   {XK_s, Key::S},
87   {XK_t, Key::T},
88   {XK_u, Key::U},
89   {XK_v, Key::V},
90   {XK_w, Key::W},
91   {XK_x, Key::X},
92   {XK_y, Key::Y},
93   {XK_z, Key::Z},
94   {XK_space, Key::SPACE},
95   {XK_ISO_Enter, Key::ENTER},
96   {XK_KP_Enter, Key::ENTER},
97   {XK_Return, Key::ENTER},
98   {XK_BackSpace, Key::BACKSPACE},
99   {XK_Delete, Key::DELETE},
100   {XK_Escape, Key::ESC},
101   {XK_Left, Key::LEFT},
102   {XK_Right, Key::RIGHT},
103   {XK_Up, Key::UP},
104   {XK_Down, Key::DOWN},
105   {XK_Control_L, Key::LEFT_CTRL},
106   {XK_Control_R, Key::RIGHT_CTRL},
107   {XK_Shift_L, Key::LEFT_SHIFT},
108   {XK_Shift_R, Key::RIGHT_CTRL},
109   {XK_Super_L, Key::LEFT_SUPER},
110   {XK_Super_R, Key::RIGHT_SUPER},
111 };
.fi

.SH "Author"
.PP 
Generated automatically by Doxygen for CYD-UI from the source code\&.
