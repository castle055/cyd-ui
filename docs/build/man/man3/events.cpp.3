.TH "src/events/events.cpp" 3 "CYD-UI" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/events/events.cpp
.SH SYNOPSIS
.br
.PP
\fC#include 'events/events\&.hpp'\fP
.br
\fC#include 'cydstd/logging\&.hpp'\fP
.br
\fC#include <deque>\fP
.br
\fC#include <list>\fP
.br
\fC#include <mutex>\fP
.br
\fC#include <unordered_map>\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBthread_data\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "static void \fBrun_event\fP (\fBthread_data\fP *data, \fBcydui::events::Event\fP *ev)"
.br
.ti -1c
.RI "void \fBpush_event\fP (\fBthread_data\fP *data, \fBcydui::events::Event\fP *ev)"
.br
.ti -1c
.RI "\fBcydui::events::Event\fP * \fBget_next_event\fP (\fBthread_data\fP *data)"
.br
.ti -1c
.RI "void \fBclean_up_event\fP (\fBthread_data\fP *data, \fBcydui::events::Event\fP *ev)"
.br
.ti -1c
.RI "void \fBprocess_event\fP (\fBthread_data\fP *data)"
.br
.ti -1c
.RI "void \fBevent_task\fP (\fBcydui::threading::thread_t\fP *this_thread)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBlogging::logger\fP \fBlog_task\fP"
.br
.ti -1c
.RI "\fBlogging::logger\fP \fBlog_ctrl\fP"
.br
.ti -1c
.RI "\fBcydui::threading::thread_t\fP * \fBevent_thread\fP"
.br
.ti -1c
.RI "\fBthread_data\fP * \fBth_data\fP = new \fBthread_data\fP"
.br
.ti -1c
.RI "std::mutex \fBevent_mutex\fP"
.br
.ti -1c
.RI "std::mutex \fBlisteners_mutex\fP"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "void clean_up_event (\fBthread_data\fP * data, \fBcydui::events::Event\fP * ev)"

.PP
Definition at line \fB75\fP of file \fBevents\&.cpp\fP\&..PP
.nf
75                                                              {
76   event_mutex\&.lock();
77   data\->event_queue\->pop_front();
78   if (data\->event_queue\->empty())
79     data\->pending = false;
80   ev\->ev_mtx\&.lock();
81   ev\->status = cydui::events::CONSUMED;
82   ev\->ev_mtx\&.unlock();
83   log_task\&.debug("DONE WITH EVENT: %s %s", ev\->type\&.c_str(), ev\->managed ? "" : "[deleting]");
84   if (!ev\->managed) delete ev;
85   event_mutex\&.unlock();
86 }
.fi

.SS "void event_task (\fBcydui::threading::thread_t\fP * this_thread)"

.PP
Definition at line \fB102\fP of file \fBevents\&.cpp\fP\&..PP
.nf
102                                                      {
103   log_task\&.debug("Started event_task");
104   auto t0 = std::chrono::system_clock::now();
105   while (this_thread\->running) {
106     t0 = std::chrono::system_clock::now();
107     process_event((thread_data*) (this_thread\->data));
108     std::this_thread::sleep_until(t0 + 100us);
109   }
110 }
.fi

.SS "\fBcydui::events::Event\fP * get_next_event (\fBthread_data\fP * data)"

.PP
Definition at line \fB62\fP of file \fBevents\&.cpp\fP\&..PP
.nf
62                                                     {
63   cydui::events::Event* ev = nullptr;
64   
65   //event_mutex\&.lock();
66   if (data\->pending) {
67     //    log_task\&.info("EV QUEUE: %d", data\->event_queue\->size());
68     ev = data\->event_queue\->front();
69   }
70   //event_mutex\&.unlock();
71   
72   return ev;
73 }
.fi

.SS "void process_event (\fBthread_data\fP * data)"

.PP
Definition at line \fB88\fP of file \fBevents\&.cpp\fP\&..PP
.nf
88                                       {
89   //    log_task\&.debug("Processing next event");
90   
91   log_task\&.debug("EVENT COUNT: %ld", data\->event_queue\->size());
92   cydui::events::Event* ev = get_next_event(data);
93   
94   if (ev != nullptr) {
95     run_event(data, ev);
96     clean_up_event(data, ev);
97   }
98 }
.fi

.SS "void push_event (\fBthread_data\fP * data, \fBcydui::events::Event\fP * ev)"

.PP
Definition at line \fB54\fP of file \fBevents\&.cpp\fP\&..PP
.nf
54                                                          {
55   event_mutex\&.lock();
56   data\->event_queue\->push_back(ev);
57   data\->pending = true;
58   log_task\&.debug("NEW EVENT: %s", ev\->type\&.c_str());
59   event_mutex\&.unlock();
60 }
.fi

.SS "static void run_event (\fBthread_data\fP * data, \fBcydui::events::Event\fP * ev)\fC [static]\fP"

.PP
Definition at line \fB41\fP of file \fBevents\&.cpp\fP\&..PP
.nf
41                                                                {
42   ev\->ev_mtx\&.lock();
43   ev\->status = cydui::events::PROCESSING;
44   ev\->ev_mtx\&.unlock();
45   listeners_mutex\&.lock();
46   if (data\->event_listeners\->contains(ev\->type)) {
47     for (const auto &listener: (*data\->event_listeners)[ev\->type]) {
48       listener(ev);
49     }
50   }
51   listeners_mutex\&.unlock();
52 }
.fi

.SH "Variable Documentation"
.PP 
.SS "std::mutex event_mutex"

.PP
Definition at line \fB37\fP of file \fBevents\&.cpp\fP\&.
.SS "\fBcydui::threading::thread_t\fP* event_thread"

.PP
Definition at line \fB20\fP of file \fBevents\&.cpp\fP\&.
.SS "std::mutex listeners_mutex"

.PP
Definition at line \fB38\fP of file \fBevents\&.cpp\fP\&.
.SS "\fBlogging::logger\fP log_ctrl"
\fBInitial value:\fP.PP
.nf
=
  {\&.name = "EV_CTRL", \&.on = false}
.fi

.PP
Definition at line \fB17\fP of file \fBevents\&.cpp\fP\&..PP
.nf
18   {\&.name = "EV_CTRL", \&.on = false};
.fi

.SS "\fBlogging::logger\fP log_task"
\fBInitial value:\fP.PP
.nf
=
  {\&.name = "EV_TASK", \&.on = true, \&.min_level = logging::INFO}
.fi

.PP
Definition at line \fB15\fP of file \fBevents\&.cpp\fP\&..PP
.nf
16   {\&.name = "EV_TASK", \&.on = true, \&.min_level = logging::INFO};
.fi

.SS "\fBthread_data\fP* th_data = new \fBthread_data\fP"

.PP
Definition at line \fB34\fP of file \fBevents\&.cpp\fP\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for CYD-UI from the source code\&.
  });
189         } else if (ev\&.xbutton\&.button == 5) {
190           //emit<ScrollEvent>({
191           //  \&.win = (unsigned int) ev\&.xbutton\&.window,
192           //  \&.dy = \-64,
193           //  \&.x = ev\&.xbutton\&.x,
194           //  \&.y = ev\&.xbutton\&.y,
195           //});
196           vScrollEventDataMonitor\&.update({
197             \&.win = (unsigned int) ev\&.xbutton\&.window,
198             \&.dy = \-64,
199             \&.x = ev\&.xbutton\&.x,
200             \&.y = ev\&.xbutton\&.y,
201           });
202         } else if (ev\&.xbutton\&.button == 6) {
203           hScrollEventDataMonitor\&.update({
204             \&.win = (unsigned int) ev\&.xbutton\&.window,
205             \&.dx = \-64,
206             \&.x = ev\&.xbutton\&.x,
207             \&.y = ev\&.xbutton\&.y,
208           });
209         } else if (ev\&.xbutton\&.button == 7) {
210           hScrollEventDataMonitor\&.update({
211             \&.win = (unsigned int) ev\&.xbutton\&.window,
212             \&.dx = 64,
213             \&.x = ev\&.xbutton\&.x,
214             \&.y = ev\&.xbutton\&.y,
215           });
216         } else {
217           emit<ButtonEvent>({
218             \&.win = (unsigned int) ev\&.xbutton\&.window,
219             \&.button = ev\&.xbutton\&.button,
220             \&.x      = ev\&.xbutton\&.x,
221             \&.y      = ev\&.xbutton\&.y,
222             \&.pressed = true,
223           });
224         }
225         break;
226       case ButtonRelease:
227         if (4 != ev\&.xbutton\&.button
228           && 5 != ev\&.xbutton\&.button
229           && 6 != ev\&.xbutton\&.button
230           && 7 != ev\&.xbutton\&.button
231           ) {
232           emit<ButtonEvent>({
233             \&.win = (unsigned int) ev\&.xbutton\&.window,
234             \&.button = ev\&.xbutton\&.button,
235             \&.x      = ev\&.xbutton\&.x,
236             \&.y      = ev\&.xbutton\&.y,
237             \&.released = true,
238           });
239         }
240         break;
241       case MotionNotify://x11_evlog\&.info("%d\-%d", ev\&.xmotion\&.x, ev\&.xmotion\&.y);
242         //x11_evlog\&.warn("%lX \- MOTION", ev\&.xmotion\&.window);
243         motionEventDataMonitor\&.update({
244           \&.win = (unsigned int) ev\&.xmotion\&.window,
245           \&.x = ev\&.xmotion\&.x,
246           \&.y = ev\&.xmotion\&.y,
247           \&.dragging = (ev\&.xmotion\&.state & Button1Mask) > 0,
248         });
249         break;
250       case ConfigureNotify://x11_evlog\&.info("%d\-%d", ev\&.xconfigure\&.width, ev\&.xconfigure\&.height);
251         resizeEventDataMonitor\&.update({
252           \&.win = (unsigned int) ev\&.xconfigure\&.window,
253           \&.w = ev\&.xconfigure\&.width,
254           \&.h = ev\&.xconfigure\&.height,
255         });
256         break;
257       case EnterNotify:
258         break;
259       case LeaveNotify:
261         emit<MotionEvent>({
262           \&.win = (unsigned int) ev\&.xcrossing\&.window,
263           \&.x = \-1,
264           \&.y = \-1,
265         });
266         redrawEventDataMonitor\&.update({
267           \&.win = (unsigned int) ev\&.xcrossing\&.window,
268         });
269         break;
270       case FocusIn:
271         //x11_evlog\&.error("%lX \- FOCUS IN", ev\&.xfocus\&.window);
272         break;
273       case FocusOut:
274         //x11_evlog\&.error("%lX \- FOCUS OUT", ev\&.xfocus\&.window);
275         break;
276       case KeymapNotify:
277       case CreateNotify:
278       case DestroyNotify:
279       case UnmapNotify:
280       case ResizeRequest:
281       case MapRequest:
282       case ReparentNotify:
283       case ConfigureRequest:
284       case GravityNotify:
285       case CirculateNotify:
286       case CirculateRequest:
287       case PropertyNotify:
288       case SelectionClear:
289       case SelectionRequest:
290       case SelectionNotify:
291       case ColormapNotify:
292       case ClientMessage:
293       case MappingNotify:
294       case GenericEvent:
295       default:
296         break;
297     }
298   }
299   XFlush(state::get_dpy());
300 }
.fi

.SS "void x11_event_emitter_task (\fBcydui::threading::thread_t\fP * this_thread)"

.PP
Definition at line \fB304\fP of file \fBevents\&.cpp\fP\&..PP
.nf
304                                                                  {
305   xim = XOpenIM(state::get_dpy(), NULL, NULL, NULL);
306   xic = XCreateIC(xim,
307     XNInputStyle, XIMPreeditNothing | XIMStatusNothing,
308     NULL
309   );
310   while (this_thread\->running) {
311     run();
312     std::this_thread::sleep_for(20ms);
313   }
314   XDestroyIC(xic);
315   XCloseIM(xim);
316 }
.fi

.SH "Variable Documentation"
.PP 
.SS "\fBlogging::logger\fP chev_log = {\&.name = 'EV::CHANGE', \&.on = false}"

.PP
Definition at line \fB14\fP of file \fBevents\&.cpp\fP\&..PP
.nf
14 {\&.name = "EV::CHANGE", \&.on = false};
.fi

.SS "\fBcydui::events::change_ev::DataMonitor\fP< \fBScrollEvent\fP > hScrollEventDataMonitor([](\fBScrollEvent::DataType\fP &o_data, \fBScrollEvent::DataType\fP &n_data) { n_data\&.dx+=o_data\&.dx;return true;},[](\fBScrollEvent::DataType\fP &data) { data\&.dx=0;}) ([] (\fBScrollEvent::DataType\fP &o_data, \fBScrollEvent::DataType\fP &n_data) { n_data\&.dx+=o_data\&.dx;return true;}, [] (\fBScrollEvent::DataType\fP &data) { data\&.dx=0;})"

.PP
This prevents the event thread from chocking on scroll events\&. 
.PP
\fBNote\fP
.RS 4
It does impose a limit on the scroll speed to 64 units per frame in either direction 
.RE
.PP

.SS "char input_buffer[10]"

.PP
Definition at line \fB113\fP of file \fBevents\&.cpp\fP\&.
.SS "KeySym ksym"

.PP
Definition at line \fB117\fP of file \fBevents\&.cpp\fP\&.
.SS "\fBcydui::events::change_ev::DataMonitor\fP< \fBMotionEvent\fP > motionEventDataMonitor([](\fBMotionEvent::DataType\fP &o_data, \fBMotionEvent::DataType\fP &n_data) { return true;}) ([] (\fBMotionEvent::DataType\fP &o_data, \fBMotionEvent::DataType\fP &n_data) { return true;})"

.SS "\fBcydui::events::change_ev::DataMonitor\fP< \fBRedrawEvent\fP > redrawEventDataMonitor([](\fBRedrawEvent::DataType\fP &o_data, \fBRedrawEvent::DataType\fP &n_data) { return true;}) ([] (\fBRedrawEvent::DataType\fP &o_data, \fBRedrawEvent::DataType\fP &n_data) { return true;})"

.SS "\fBcydui::events::change_ev::DataMonitor\fP< \fBResizeEvent\fP > resizeEventDataMonitor([](\fBResizeEvent::DataType\fP &o_data, \fBResizeEvent::DataType\fP &n_data) { return(o_data\&.w !=n_data\&.w||o_data\&.h !=n_data\&.h); }) ([] (\fBResizeEvent::DataType\fP &o_data, \fBResizeEvent::DataType\fP &n_data) { return(o_data\&.w !=n_data\&.w||o_data\&.h !=n_data\&.h);})"

.SS "Status st"

.PP
Definition at line \fB116\fP of file \fBevents\&.cpp\fP\&.
.SS "\fBcydui::events::change_ev::DataMonitor\fP< \fBScrollEvent\fP > vScrollEventDataMonitor([](\fBScrollEvent::DataType\fP &o_data, \fBScrollEvent::DataType\fP &n_data) { n_data\&.dy+=o_data\&.dy;return true;},[](\fBScrollEvent::DataType\fP &data) { data\&.dy=0;}) ([] (\fBScrollEvent::DataType\fP &o_data, \fBScrollEvent::DataType\fP &n_data) { n_data\&.dy+=o_data\&.dy;return true;}, [] (\fBScrollEvent::DataType\fP &data) { data\&.dy=0;})"

.PP
This prevents the event thread from chocking on scroll events\&. 
.PP
\fBNote\fP
.RS 4
It does impose a limit on the scroll speed to 64 units per frame in either direction 
.RE
.PP

.SS "\fBlogging::logger\fP x11_evlog = {\&.name = 'X11::EV'}"

.PP
Definition at line \fB13\fP of file \fBevents\&.cpp\fP\&..PP
.nf
13 {\&.name = "X11::EV"};
.fi

.SS "\fBcydui::threading::thread_t\fP* x11_thread"

.PP
Definition at line \fB11\fP of file \fBevents\&.cpp\fP\&.
.SS "XIC xic\fC [static]\fP"

.PP
Definition at line \fB115\fP of file \fBevents\&.cpp\fP\&.
.SS "XIM xim\fC [static]\fP"

.PP
Definition at line \fB114\fP of file \fBevents\&.cpp\fP\&.
.SS "std::unordered_map<KeySym, \fBKey\fP> xkey_map\fC [static]\fP"

.PP
Definition at line \fB67\fP of file \fBevents\&.cpp\fP\&..PP
.nf
67                                                  {
68   {XK_a, Key::A},
69   {XK_b, Key::B},
70   {XK_c, Key::C},
71   {XK_d, Key::D},
72   {XK_e, Key::E},
73   {XK_f, Key::F},
74   {XK_g, Key::G},
75   {XK_h, Key::H},
76   {XK_i, Key::I},
77   {XK_j, Key::J},
78   {XK_k, Key::K},
79   {XK_l, Key::L},
80   {XK_m, Key::M},
81   {XK_n, Key::N},
82   {XK_o, Key::O},
83   {XK_p, Key::P},
84   {XK_q, Key::Q},
85   {XK_r, Key::R},
86   {XK_s, Key::S},
87   {XK_t, Key::T},
88   {XK_u, Key::U},
89   {XK_v, Key::V},
90   {XK_w, Key::W},
91   {XK_x, Key::X},
92   {XK_y, Key::Y},
93   {XK_z, Key::Z},
94   {XK_space, Key::SPACE},
95   {XK_ISO_Enter, Key::ENTER},
96   {XK_KP_Enter, Key::ENTER},
97   {XK_Return, Key::ENTER},
98   {XK_BackSpace, Key::BACKSPACE},
99   {XK_Delete, Key::DELETE},
100   {XK_Escape, Key::ESC},
101   {XK_Left, Key::LEFT},
102   {XK_Right, Key::RIGHT},
103   {XK_Up, Key::UP},
104   {XK_Down, Key::DOWN},
105   {XK_Control_L, Key::LEFT_CTRL},
106   {XK_Control_R, Key::RIGHT_CTRL},
107   {XK_Shift_L, Key::LEFT_SHIFT},
108   {XK_Shift_R, Key::RIGHT_CTRL},
109   {XK_Super_L, Key::LEFT_SUPER},
110   {XK_Super_R, Key::RIGHT_SUPER},
111 };
.fi

.SH "Author"
.PP 
Generated automatically by Doxygen for CYD-UI from the source code\&.
