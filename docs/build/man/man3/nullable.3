.TH "nullable< T >" 3 "CYD-UI" \" -*- nroff -*-
.ad l
.nh
.SH NAME
nullable< T >
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <nullable\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBoperator bool\fP () const"
.br
.ti -1c
.RI "\fBnullable\fP ()=default"
.br
.ti -1c
.RI "\fB~nullable\fP ()"
.br
.ti -1c
.RI "\fBnullable\fP (\fBT\fP &t)"
.br
.ti -1c
.RI "\fBnullable\fP (const \fBT\fP &t)"
.br
.ti -1c
.RI "\fBnullable\fP (\fBT\fP *t)"
.br
.ti -1c
.RI "\fBnullable\fP (const \fBT\fP *t)"
.br
.ti -1c
.RI "\fBnullable\fP< \fBT\fP > & \fBoperator=\fP (\fBT\fP new_val)"
.br
.ti -1c
.RI "void \fBset_null\fP ()"
.br
.ti -1c
.RI "template<typename \fBR\fP > \fBnullable\fP< \fBR\fP > \fBlet\fP (const std::function< \fBR\fP(\fBT\fP)> &block)"
.br
.ti -1c
.RI "template<typename \fBR\fP > \fBnullable\fP< \fBR\fP > \fBlet\fP (const std::function< \fBnullable\fP< \fBR\fP >(\fBT\fP)> &block)"
.br
.ti -1c
.RI "template<typename \fBR\fP > \fBnullable\fP< \fBR\fP > \fBlet\fP (const std::function< \fBR\fP(\fBT\fP &)> &block)"
.br
.ti -1c
.RI "template<typename \fBR\fP > \fBnullable\fP< \fBR\fP > \fBlet\fP (const std::function< \fBnullable\fP< \fBR\fP >(\fBT\fP &)> &block)"
.br
.ti -1c
.RI "template<typename \fBR\fP > \fBnullable\fP< \fBR\fP > \fBlet\fP (const std::function< \fBR\fP(const \fBT\fP &)> &block) const"
.br
.ti -1c
.RI "template<typename \fBR\fP > \fBnullable\fP< \fBR\fP > \fBlet\fP (const std::function< \fBnullable\fP< \fBR\fP >(const \fBT\fP &)> &block) const"
.br
.ti -1c
.RI "\fBnullable\fP< \fBT\fP > \fBlet\fP (const std::function< void(\fBT\fP)> &block)"
.br
.ti -1c
.RI "\fBnullable\fP< \fBT\fP > \fBlet\fP (const std::function< \fBnullable\fP< \fBT\fP >(\fBT\fP)> &block)"
.br
.ti -1c
.RI "\fBnullable\fP< \fBT\fP > \fBlet\fP (const std::function< void(\fBT\fP &)> &block)"
.br
.ti -1c
.RI "\fBnullable\fP< \fBT\fP > \fBlet\fP (const std::function< void(const \fBT\fP &)> &block) const"
.br
.ti -1c
.RI "\fBnullable\fP< \fBT\fP > & \fBalso\fP (const std::function< void(\fBT\fP &)> &block)"
.br
.ti -1c
.RI "\fBT\fP \fBoperatoror\fP (\fBT\fP other)"
.br
.ti -1c
.RI "void \fBoperatoror\fP (const std::function< void()> &block)"
.br
.ti -1c
.RI "\fBnullable\fP< \fBT\fP > \fBoperatoror\fP (const std::function< \fBT\fP()> &block) const"
.br
.ti -1c
.RI "\fBT\fP * \fBunwrap\fP () const"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBT\fP * \fBvalue\fP = nullptr"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename \fBT\fP>
.br
class nullable< T >"
.PP
Definition at line \fB19\fP of file \fBnullable\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename \fBT\fP > \fBnullable\fP< \fBT\fP >\fB::nullable\fP ()\fC [default]\fP"

.SS "template<typename \fBT\fP > \fBnullable\fP< \fBT\fP >::~\fBnullable\fP ()\fC [inline]\fP"

.PP
Definition at line \fB28\fP of file \fBnullable\&.h\fP\&..PP
.nf
28               {
29     if (value != nullptr) {
30       delete value;
31       value == nullptr;
32     }
33   }
.fi

.SS "template<typename \fBT\fP > \fBnullable\fP< \fBT\fP >\fB::nullable\fP (\fBT\fP & t)\fC [inline]\fP"

.PP
Definition at line \fB35\fP of file \fBnullable\&.h\fP\&..PP
.nf
35                  {
36     value = new T(t);
37   }
.fi

.SS "template<typename \fBT\fP > \fBnullable\fP< \fBT\fP >\fB::nullable\fP (const \fBT\fP & t)\fC [inline]\fP"

.PP
Definition at line \fB39\fP of file \fBnullable\&.h\fP\&..PP
.nf
39                        {
40     value = new T(t);
41   }
.fi

.SS "template<typename \fBT\fP > \fBnullable\fP< \fBT\fP >\fB::nullable\fP (\fBT\fP * t)\fC [inline]\fP"

.PP
Definition at line \fB43\fP of file \fBnullable\&.h\fP\&..PP
.nf
43                  {
44     value = t;
45   }
.fi

.SS "template<typename \fBT\fP > \fBnullable\fP< \fBT\fP >\fB::nullable\fP (const \fBT\fP * t)\fC [inline]\fP"

.PP
Definition at line \fB47\fP of file \fBnullable\&.h\fP\&..PP
.nf
47                        {
48     value = t;
49   }
.fi

.SH "Member Function Documentation"
.PP 
.SS "template<typename \fBT\fP > \fBnullable\fP< \fBT\fP > & \fBnullable\fP< \fBT\fP >::also (const std::function< void(\fBT\fP &)> & block)\fC [inline]\fP"

.PP
Definition at line \fB156\fP of file \fBnullable\&.h\fP\&..PP
.nf
156                                                          {
157     if (value != nullptr) {
158       block(*value);
159     }
160     return *this;
161   }
.fi

.SS "template<typename \fBT\fP > template<typename \fBR\fP > \fBnullable\fP< \fBR\fP > \fBnullable\fP< \fBT\fP >::let (const std::function< \fBnullable\fP< \fBR\fP >(const \fBT\fP &)> & block) const\fC [inline]\fP"

.PP
Definition at line \fB108\fP of file \fBnullable\&.h\fP\&..PP
.nf
108                                                                           {
109     if (value != nullptr) {
110       return block(*value);
111     }
112     return nullable<R>();
113   }
.fi

.SS "template<typename \fBT\fP > template<typename \fBR\fP > \fBnullable\fP< \fBR\fP > \fBnullable\fP< \fBT\fP >::let (const std::function< \fBnullable\fP< \fBR\fP >(\fBT\fP &)> & block)\fC [inline]\fP"

.PP
Definition at line \fB92\fP of file \fBnullable\&.h\fP\&..PP
.nf
92                                                               {
93     if (value != nullptr) {
94       return block(*value);
95     }
96     return nullable<R>();
97   }
.fi

.SS "template<typename \fBT\fP > template<typename \fBR\fP > \fBnullable\fP< \fBR\fP > \fBnullable\fP< \fBT\fP >::let (const std::function< \fBnullable\fP< \fBR\fP >(\fBT\fP)> & block)\fC [inline]\fP"

.PP
Definition at line \fB76\fP of file \fBnullable\&.h\fP\&..PP
.nf
76                                                             {
77     if (value != nullptr) {
78       return block(*value);
79     }
80     return nullable<R>();
81   }
.fi

.SS "template<typename \fBT\fP > \fBnullable\fP< \fBT\fP > \fBnullable\fP< \fBT\fP >::let (const std::function< \fBnullable\fP< \fBT\fP >(\fBT\fP)> & block)\fC [inline]\fP"

.PP
Definition at line \fB123\fP of file \fBnullable\&.h\fP\&..PP
.nf
123                                                             {
124     if (value != nullptr) {
125       block(*value);
126     }
127     return nullable<T>();
128   }
.fi

.SS "template<typename \fBT\fP > template<typename \fBR\fP > \fBnullable\fP< \fBR\fP > \fBnullable\fP< \fBT\fP >::let (const std::function< \fBR\fP(const \fBT\fP &)> & block) const\fC [inline]\fP"

.PP
Definition at line \fB100\fP of file \fBnullable\&.h\fP\&..PP
.nf
100                                                                 {
101     if (value != nullptr) {
102       return block(*value);
103     }
104     return nullable<R>();
105   }
.fi

.SS "template<typename \fBT\fP > template<typename \fBR\fP > \fBnullable\fP< \fBR\fP > \fBnullable\fP< \fBT\fP >::let (const std::function< \fBR\fP(\fBT\fP &)> & block)\fC [inline]\fP"

.PP
Definition at line \fB84\fP of file \fBnullable\&.h\fP\&..PP
.nf
84                                                     {
85     if (value != nullptr) {
86       return block(*value);
87     }
88     return nullable<R>();
89   }
.fi

.SS "template<typename \fBT\fP > template<typename \fBR\fP > \fBnullable\fP< \fBR\fP > \fBnullable\fP< \fBT\fP >::let (const std::function< \fBR\fP(\fBT\fP)> & block)\fC [inline]\fP"

.PP
Definition at line \fB68\fP of file \fBnullable\&.h\fP\&..PP
.nf
68                                                   {
69     if (value != nullptr) {
70       return block(*value);
71     }
72     return nullable<R>();
73   }
.fi

.SS "template<typename \fBT\fP > \fBnullable\fP< \fBT\fP > \fBnullable\fP< \fBT\fP >::let (const std::function< void(const \fBT\fP &)> & block) const\fC [inline]\fP"

.PP
Definition at line \fB137\fP of file \fBnullable\&.h\fP\&..PP
.nf
137                                                                    {
138     if (value != nullptr) {
139       block(*value);
140     }
141     return nullable<T>();
142   }
.fi

.SS "template<typename \fBT\fP > \fBnullable\fP< \fBT\fP > \fBnullable\fP< \fBT\fP >::let (const std::function< void(\fBT\fP &)> & block)\fC [inline]\fP"

.PP
Definition at line \fB130\fP of file \fBnullable\&.h\fP\&..PP
.nf
130                                                        {
131     if (value != nullptr) {
132       block(*value);
133     }
134     return nullable<T>();
135   }
.fi

.SS "template<typename \fBT\fP > \fBnullable\fP< \fBT\fP > \fBnullable\fP< \fBT\fP >::let (const std::function< void(\fBT\fP)> & block)\fC [inline]\fP"

.PP
Definition at line \fB116\fP of file \fBnullable\&.h\fP\&..PP
.nf
116                                                      {
117     if (value != nullptr) {
118       block(*value);
119     }
120     return nullable<T>();
121   }
.fi

.SS "template<typename \fBT\fP > \fBnullable\fP< \fBT\fP >::operator bool () const\fC [inline]\fP, \fC [explicit]\fP"

.PP
Definition at line \fB22\fP of file \fBnullable\&.h\fP\&..PP
.nf
22                                  {
23     return value != nullptr;
24   }
.fi

.SS "template<typename \fBT\fP > \fBnullable\fP< \fBT\fP > & \fBnullable\fP< \fBT\fP >::operator= (\fBT\fP new_val)\fC [inline]\fP"

.PP
Definition at line \fB51\fP of file \fBnullable\&.h\fP\&..PP
.nf
51                                     {
52     if (value == nullptr) {
53       value = new T(new_val);
54     } else {
55       *value = new_val;
56     }
57     return *this;
58   }
.fi

.SS "template<typename \fBT\fP > \fBnullable\fP< \fBT\fP > \fBnullable\fP< \fBT\fP >::operatoror (const std::function< \fBT\fP()> & block) const\fC [inline]\fP"

.PP
Definition at line \fB177\fP of file \fBnullable\&.h\fP\&..PP
.nf
177                                                               {
178     if (value == nullptr) {
179       return block();
180     }
181     return this;
182   }
.fi

.SS "template<typename \fBT\fP > void \fBnullable\fP< \fBT\fP >::operatoror (const std::function< void()> & block)\fC [inline]\fP"

.PP
Definition at line \fB171\fP of file \fBnullable\&.h\fP\&..PP
.nf
171                                                     {
172     if (value == nullptr) {
173       block();
174     }
175   }
.fi

.SS "template<typename \fBT\fP > \fBT\fP \fBnullable\fP< \fBT\fP >::operatoror (\fBT\fP other)\fC [inline]\fP"

.PP
Definition at line \fB163\fP of file \fBnullable\&.h\fP\&..PP
.nf
163                         {
164     if (value != nullptr) {
165       return *value;
166     } else {
167       return other;
168     }
169   }
.fi

.SS "template<typename \fBT\fP > void \fBnullable\fP< \fBT\fP >::set_null ()\fC [inline]\fP"

.PP
Definition at line \fB60\fP of file \fBnullable\&.h\fP\&..PP
.nf
60                   {
61     if (value != nullptr) {
62       delete value;
63       value = nullptr;
64     }
65   }
.fi

.SS "template<typename \fBT\fP > \fBT\fP * \fBnullable\fP< \fBT\fP >::unwrap () const\fC [inline]\fP"

.PP
Definition at line \fB184\fP of file \fBnullable\&.h\fP\&..PP
.nf
184                     {
185     if (value == nullptr) {
186       throw std::out_of_range("Nullable was null when it was not supposed to!");
187     } else {
188       return value;
189     }
190   }
.fi

.SH "Member Data Documentation"
.PP 
.SS "template<typename \fBT\fP > \fBT\fP* \fBnullable\fP< \fBT\fP >::value = nullptr\fC [private]\fP"

.PP
Definition at line \fB20\fP of file \fBnullable\&.h\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for CYD-UI from the source code\&.
