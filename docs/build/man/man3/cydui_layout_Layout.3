.TH "cydui::layout::Layout" 3 "CYD-UI" \" -*- nroff -*-
.ad l
.nh
.SH NAME
cydui::layout::Layout
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <layout\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fB~Layout\fP ()"
.br
.ti -1c
.RI "void \fBbind_window\fP (\fBwindow::CWindow\fP *_win)"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "\fBcomponents::component_base_t\fP * \fBfind_by_coords\fP (int x, int y)"
.br
.ti -1c
.RI "\fBLayout\fP (\fBcomponents::component_state_t\fP *_root_state, \fBcomponents::component_base_t\fP *_root)"
.br
.ti -1c
.RI "bool \fBrender_if_dirty\fP (\fBcomponents::component_base_t\fP *c)"
.br
.ti -1c
.RI "void \fBredraw_component\fP (\fBcomponents::component_base_t\fP *target)"
.br
.ti -1c
.RI "void \fBrecompute_dimensions\fP (\fBcomponents::component_base_t\fP *start_from)"
.br
.ti -1c
.RI "void \fBrecompose_layout\fP ()"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBwindow::CWindow\fP * \fBwin\fP = nullptr"
.br
.ti -1c
.RI "\fBcompositing::LayoutCompositor\fP \fBcompositor\fP {}"
.br
.ti -1c
.RI "\fBcomponents::component_state_t\fP * \fBroot_state\fP"
.br
.ti -1c
.RI "\fBcomponents::component_base_t\fP * \fBroot\fP"
.br
.ti -1c
.RI "\fBcomponents::component_state_t\fP * \fBhovering\fP = nullptr"
.br
.ti -1c
.RI "\fBcomponents::component_state_t\fP * \fBfocused\fP = nullptr"
.br
.ti -1c
.RI "std::vector< \fBevents::listener_t\fP * > \fBlisteners\fP {}"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "template<components::ComponentConcept C> \fBLayout\fP * \fBcydui::layout::create\fP (\fBC\fP &&root_component)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line \fB21\fP of file \fBlayout\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "cydui::layout::Layout::Layout (\fBcomponents::component_state_t\fP * _root_state, \fBcomponents::component_base_t\fP * _root)\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line \fB36\fP of file \fBlayout\&.h\fP\&..PP
.nf
37         : root_state(_root_state), root(_root), focused(_root_state) {
38         focused\->focused = true;
39       }
.fi

.SS "cydui::layout::Layout::~Layout ()\fC [inline]\fP"

.PP
Definition at line \fB53\fP of file \fBlayout\&.h\fP\&..PP
.nf
53                 {
54         for (auto &item: listeners) {
55           item\->remove();
56           delete item;
57         }
58       }
.fi

.SH "Member Function Documentation"
.PP 
.SS "void cydui::layout::Layout::bind_window (\fBwindow::CWindow\fP * _win)"
Configure root component
.PP
Definition at line \fB168\fP of file \fBlayout\&.cpp\fP\&..PP
.nf
168                                                             {
169   this\->win = _win;
170   compositor\&.set_render_target(this\->win\->win_ref, &this\->win\->profiling_ctx);
171   {
172     root_state\->win = this\->win;
173     
174     auto dim = root\->get_dimensional_relations();
175     dim\&.w = get_frame(this\->win\->win_ref)\->width();
176     dim\&.h = get_frame(this\->win\->win_ref)\->height();
177     dim\&.fixed_w = true;
178     dim\&.fixed_h = true;
179     root\->configure_event_handler();
180     root\->subscribe_events();
181   }
182   
183   listeners\&.push_back(listen(RedrawEvent, {
184     if (it\&.data\->win != get_id(win\->win_ref))
185       return;
186     auto _pev = this\->win\->profiling_ctx\&.scope_event("Redraw");
187     if (it\&.data\->component) {
188       component_state_t* target_state =
189         ((component_state_t*) it\&.data\->component);
190       if (target_state\->component_instance\&.has_value()) {
191         redraw_component(target_state\->component_instance\&.value());
192       }
193     } else {
194       redraw_component(root);
195     }
196   }));
197   listeners\&.push_back(listen(KeyEvent, {
198     if (it\&.data\->win != get_id(win\->win_ref))
199       return;
200     auto _pev = this\->win\->profiling_ctx\&.scope_event("Key");
201     if (focused && focused\->component_instance) {
202       if (focused\->focused) {
203         if (it\&.data\->pressed) {
204           INSTANCE_EV_HANDLER(focused)\->on_key_press(*it\&.data);
205         } else if (it\&.data\->released) {
206           INSTANCE_EV_HANDLER(focused)\->on_key_release(*it\&.data);
207         }
208       } else {
209         focused = nullptr;
210       }
211     }
212   }));
213   listeners\&.push_back(listen(ButtonEvent, {
214     if (it\&.data\->win != get_id(win\->win_ref))
215       return;
216     auto _pev = this\->win\->profiling_ctx\&.scope_event("Button");
217     
218     component_base_t* target = root;
219     component_base_t* specified_target = find_by_coords(it\&.data\->x, it\&.data\->y);
220     if (specified_target) {
221       target = specified_target;
222     }
223     
224     auto dim = target\->get_dimensional_relations();
225     int rel_x = it\&.data\->x \- dim\&.cx\&.val();
226     int rel_y = it\&.data\->y \- dim\&.cy\&.val();
227     
228     if (focused != target\->state\&.value()) {
229       if (focused) {
230         //if (focused\->component_instance\&.has_value()) {
231         //  focused\->component_instance\&.value()
232         //    \->event_handler()
233         //    \->on_button_release((Button) it\&.data\->button, 0, 0);
234         //}
235         focused\->focused = false;
236         focused = nullptr;
237       }
238       focused = target\->state\&.value();
239       focused\->focused = true;
240     }
241     
242     if (it\&.data\->pressed) {
243       target\->event_handler()\->on_button_press((Button) it\&.data\->button, rel_x, rel_y);
244     } else {
245       target\->event_handler()\->on_button_release((Button) it\&.data\->button, rel_x, rel_y);
246     }
247     render_if_dirty(root);
248   }));
249   listeners\&.push_back(listen(ScrollEvent, {
250     if (it\&.data\->win != get_id(win\->win_ref))
251       return;
252     auto _pev = this\->win\->profiling_ctx\&.scope_event("Scroll");
253     component_base_t* target = root;
254     component_base_t* specified_target = find_by_coords(it\&.data\->x, it\&.data\->y);
255     if (specified_target) {
256       target = specified_target;
257     }
258     
259     target\->event_handler()\->on_scroll(it\&.data\->dx, it\&.data\->dy);
260     
261     render_if_dirty(root);
262   }));
263   listeners\&.push_back(listen(MotionEvent, {
264     if (it\&.data\->win != get_id(win\->win_ref))
265       return;
266     auto _pev = this\->win\->profiling_ctx\&.scope_event("Motion");
267     
268     if (it\&.data\->x == \-1 && it\&.data\->y == \-1) {
269       if (hovering && hovering\->component_instance\&.has_value()) {
270         int exit_rel_x = 0;
271         int exit_rel_y = 0;
272         hovering\->hovering = false;
273         hovering\->component_instance\&.value()
274           \->event_handler()\->on_mouse_exit(0, 0);
275         hovering = nullptr;
276       }
277     } else {
278       component_base_t* target = root;
279       component_base_t* specified_target = find_by_coords(it\&.data\->x, it\&.data\->y);
280       if (specified_target)
281         target = specified_target;
282       
283       auto dim = target\->get_dimensional_relations();
284       int rel_x = it\&.data\->x \- dim\&.cx\&.val();
285       int rel_y = it\&.data\->y \- dim\&.cy\&.val();
286       
287       if (hovering != target\->state\&.value()) {
288         if (hovering && hovering\->component_instance\&.has_value()) {
289           auto h_dim = hovering\->component_instance\&.value()\->get_dimensional_relations();
290           int exit_rel_x = it\&.data\->x \- h_dim\&.cx\&.val();
291           int exit_rel_y = it\&.data\->y \- h_dim\&.cy\&.val();
292           hovering\->hovering = false;
293           hovering\->component_instance\&.value()
294             \->event_handler()\->on_mouse_exit(exit_rel_x, exit_rel_y);
295           hovering = nullptr;
296         }
297         hovering = target\->state\&.value();
298         hovering\->hovering = true;
299         
300         target\->event_handler()\->on_mouse_enter(rel_x, rel_y);
301       } else {
302         target\->event_handler()\->on_mouse_motion(rel_x, rel_y);
303       }
304     }
305     
306     // Calling 'Drag' related event handlers
307     //cydui::components::Component* target = root;
308     //cydui::components::Component* specified_target =
309     //  find_by_coords(root, it\&.data\->x, it\&.data\->y);
310     //if (specified_target)
311     //  target = specified_target;
312     //
313     //if (it\&.data\->dragging) {
314     //  if (dragging_context\&.dragging) {
315     //    int rel_x = it\&.data\->x \- (*target\->state\&.unwrap())\->dim\&.cx\&.val();
316     //    int rel_y = it\&.data\->y \- (*target\->state\&.unwrap())\->dim\&.cy\&.val();
317     //    dragging_context\&.dragging_item\&.drag_move(dragging_context\&.dragging_item, rel_x, rel_y);
318     //    target\->on_drag_motion(rel_x, rel_y);
319     //  } else {
320     //    int rel_x = it\&.data\->x \- (*target\->state\&.unwrap())\->dim\&.cx\&.val();
321     //    int rel_y = it\&.data\->y \- (*target\->state\&.unwrap())\->dim\&.cy\&.val();
322     //    target\->state\&.let(_(components::ComponentState * , {
323     //      for (auto &item : it\->draggable_sources) {
324     //        if (item\&.x \- 10 <= rel_x && rel_x <= item\&.x + 10
325     //          && item\&.y \- 10 <= rel_y && rel_y <= item\&.y + 10) {
326     //          dragging_context\&.dragging_item = item\&.start_drag(rel_x, rel_y);
327     //          break;
328     //        }
329     //      }
330     //    }));
331     //    target\->on_drag_start(rel_x, rel_y);
332     //    dragging_context\&.dragging = true;
333     //  }
334     //} else if (dragging_context\&.dragging) {
335     //  int rel_x = it\&.data\->x \- (*target\->state\&.unwrap())\->dim\&.cx\&.val();
336     //  int rel_y = it\&.data\->y \- (*target\->state\&.unwrap())\->dim\&.cy\&.val();
337     //  dragging_context\&.dragging_item\&.drag_end(dragging_context\&.dragging_item, rel_x, rel_y);
338     //  target\->on_drag_finish(rel_x, rel_y);
339     //  dragging_context\&.dragging = false;
340     //  dragging_context\&.dragging_item = drag_n_drop::draggable_t {};
341     //}
342     
343     render_if_dirty(root);
344   }));
345   listeners\&.push_back(listen(ResizeEvent, {
346     if (it\&.data\->win != get_id(win\->win_ref))
347       return;
348     auto _pev = this\->win\->profiling_ctx\&.scope_event("Resize");
349     log_lay\&.debug("RESIZE: w=%d, h=%d", it\&.data\->w, it\&.data\->h);
350     
351     auto dim = root\->get_dimensional_relations();
352     dim\&.w = it\&.data\->w;
353     dim\&.h = it\&.data\->h;
354     dim\&.fixed_w = true;
355     dim\&.fixed_h = true;
356     
357     redraw_component(root);
358   }));
359 }
.fi

.SS "\fBcomponent_base_t\fP * cydui::layout::Layout::find_by_coords (int x, int y)\fC [private]\fP"

.PP
Definition at line \fB155\fP of file \fBlayout\&.cpp\fP\&..PP
.nf
155                                                                 {
156   return root\->find_by_coords(x, y);
157 }
.fi

.SS "void cydui::layout::Layout::recompose_layout ()\fC [private]\fP"

.SS "void cydui::layout::Layout::recompute_dimensions (\fBcomponents::component_base_t\fP * start_from)\fC [private]\fP"

.PP
Definition at line \fB104\fP of file \fBlayout\&.cpp\fP\&..PP
.nf
106   {
107   if (!compute_dimensions(start_from) && start_from\->parent\&.has_value()) {
108     component_base_t* c = start_from\->parent\&.value();
109     while (c && !compute_dimensions(c)) {
110       if (!c\->parent\&.has_value()) {
111         log_lay\&.error("Could not compute dimensions");
112         // TODO \- Catch dimensional error
113       }
114       c = c\->parent\&.value();
115     }
116   }
117 }
.fi

.SS "void cydui::layout::Layout::redraw_component (\fBcomponents::component_base_t\fP * target)\fC [private]\fP"

.PP
Definition at line \fB119\fP of file \fBlayout\&.cpp\fP\&..PP
.nf
119                                                                  {
120   log_lay\&.debug("REDRAW");
121   //auto t0 = std::chrono::system_clock::now();
122   // Clear render area of component instances
123   auto* compositing_tree = new compositing::compositing_tree_t;
124   
125   // TODO \- For now the entire screen is redraw everytime, in the future it
126   // would be interesting to implement a diff algorithm that could redraw
127   // subsections of the screen\&.
128   target\->clear_children();
129   // Recreate those instances with redraw(), this set all size hints relationships
130   target\->redraw(this);
131   
132   recompute_dimensions(root);
133   
134   root\->get_fragment(this, &compositing_tree\->root);
135   //compositing_tree\->fix_dimensions();
136   
137   compositor\&.compose(compositing_tree);
138   //auto t1 = std::chrono::system_clock::now();
139   //printf("redraw time: %ld us\\n", std::chrono::duration_cast<std::chrono::microseconds>(t1 \- t0)\&.count());
140 }
.fi

.SS "bool cydui::layout::Layout::render_if_dirty (\fBcomponents::component_base_t\fP * c)\fC [private]\fP"

.PP
Definition at line \fB142\fP of file \fBlayout\&.cpp\fP\&..PP
.nf
142                                                            {
143   if (c\->state\&.value()\->_dirty) {
144     redraw_component(c);
145     return true;
146   } else {
147     bool any = false;
148     for (auto &item: c\->children)
149       any = render_if_dirty(item) || any;// ! F**K, order here matters
150     // ? render_if_dirty() needs to be called before `any` is checked\&.
151     return any;
152   }
153 }
.fi

.SH "Friends And Related Symbol Documentation"
.PP 
.SS "template<components::ComponentConcept C> \fBLayout\fP * \fBcydui::layout::create\fP (\fBC\fP && root_component)\fC [friend]\fP"

.SH "Member Data Documentation"
.PP 
.SS "\fBcompositing::LayoutCompositor\fP cydui::layout::Layout::compositor {}\fC [private]\fP"

.PP
Definition at line \fB24\fP of file \fBlayout\&.h\fP\&..PP
.nf
24 {};
.fi

.SS "\fBcomponents::component_state_t\fP* cydui::layout::Layout::focused = nullptr\fC [private]\fP"

.PP
Definition at line \fB30\fP of file \fBlayout\&.h\fP\&.
.SS "\fBcomponents::component_state_t\fP* cydui::layout::Layout::hovering = nullptr\fC [private]\fP"

.PP
Definition at line \fB29\fP of file \fBlayout\&.h\fP\&.
.SS "std::vector<\fBevents::listener_t\fP*> cydui::layout::Layout::listeners {}\fC [private]\fP"

.PP
Definition at line \fB32\fP of file \fBlayout\&.h\fP\&..PP
.nf
32 {};
.fi

.SS "\fBcomponents::component_base_t\fP* cydui::layout::Layout::root\fC [private]\fP"

.PP
Definition at line \fB27\fP of file \fBlayout\&.h\fP\&.
.SS "\fBcomponents::component_state_t\fP* cydui::layout::Layout::root_state\fC [private]\fP"

.PP
Definition at line \fB26\fP of file \fBlayout\&.h\fP\&.
.SS "\fBwindow::CWindow\fP* cydui::layout::Layout::win = nullptr\fC [private]\fP"

.PP
Definition at line \fB22\fP of file \fBlayout\&.h\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for CYD-UI from the source code\&.
