.TH "cydui::components::Component" 3 "CYD-UI" \" -*- nroff -*-
.ad l
.nh
.SH NAME
cydui::components::Component
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <components\&.hpp>\fP
.PP
Inherited by \fBHBox\fP, \fBProfiler\fP, \fBThreadTimeline\fP, and \fBVBox\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef \fBKeyEvent::DataType\fP \fBKeyData\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBComponent\fP ()"
.br
.ti -1c
.RI "\fBComponent\fP (std::function< void(\fBComponent\fP *)> inner)"
.br
.ti -1c
.RI "\fBComponent\fP (\fBComponentState\fP *\fBstate\fP)"
.br
.ti -1c
.RI "\fBComponent\fP (\fBComponentState\fP *\fBstate\fP, std::function< void(\fBComponent\fP *)> inner)"
.br
.ti -1c
.RI "virtual \fB~Component\fP ()"
.br
.ti -1c
.RI "void \fBadd\fP (const std::vector< \fBcomponent_builder_t\fP > &ichildren, bool prepend=false) const"
.br
.ti -1c
.RI "void \fBredraw\fP (\fBcydui::layout::Layout\fP *layout)"
.br
.ti -1c
.RI "void \fBrender\fP (\fBcydui::compositing::compositing_node_t\fP *node) const"
.br
.ti -1c
.RI "\fBnullable\fP< \fBComponent\fP * > \fBget_parent\fP () const"
.br
.ti -1c
.RI "virtual bool \fBis_drawable\fP () const"
.br
.ti -1c
.RI "virtual void \fBon_redraw\fP () const"
.br
.ti -1c
.RI "virtual void \fBon_render\fP (\fBvg::vg_fragment_t\fP &graphics) const"
.br
.ti -1c
.RI "virtual void \fBon_mouse_enter\fP (int x, int y) const"
.br
.ti -1c
.RI "virtual void \fBon_mouse_exit\fP (int x, int y) const"
.br
.ti -1c
.RI "virtual void \fBon_mouse_motion\fP (int x, int y) const"
.br
.ti -1c
.RI "virtual void \fBon_mouse_click\fP (int x, int y, int button) const"
.br
.ti -1c
.RI "virtual void \fBon_drag_start\fP (int x, int y) const"
.br
.ti -1c
.RI "virtual void \fBon_drag_motion\fP (int x, int y) const"
.br
.ti -1c
.RI "virtual void \fBon_drag_finish\fP (int x, int y) const"
.br
.ti -1c
.RI "virtual void \fBon_scroll\fP (int dx, int dy) const"
.br
.ti -1c
.RI "virtual void \fBon_key_press\fP (\fBKeyData\fP key) const"
.br
.ti -1c
.RI "virtual void \fBon_key_release\fP (\fBKeyData\fP key) const"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBComponent\fP * \fBnew_group\fP ()"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBnullable\fP< \fBComponent\fP * > \fBparent\fP"
.br
.ti -1c
.RI "\fBnullable\fP< \fBComponentState\fP * > \fBstate\fP"
.br
.ti -1c
.RI "\fBcydui::dimensions::component_dimensions_t\fP * \fBdim\fP"
.br
.ti -1c
.RI "std::deque< \fBComponent\fP * > \fBchildren\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "template<typename c , int ID> 
.br
requires \fBComponentConcept\fP<c>\fBcomponent_builder_t\fP \fBcreate\fP (\fBc_init_t\fP< c > \fBinit\fP) const"
.br
.ti -1c
.RI "template<typename c , int ID, typename \fBT\fP > 
.br
requires \fBComponentConcept\fP<c>\fBcomponent_builder_t\fP \fBcreate_for\fP (const \fBT\fP &iter, std::function< \fBc_init_t\fP< c >(const typename T::value_type &)> block) const"
.br
.ti -1c
.RI "\fBcomponent_builder_t\fP \fBcreate_group\fP (std::vector< \fBcomponent_builder_t\fP > _children) const"
.br
.in -1c
.SS "Static Private Member Functions"

.in +1c
.ti -1c
.RI "template<typename c > 
.br
requires \fBComponentConcept\fP<c>static std::function< void(\fBComponent\fP *)> \fBget_init_function\fP (\fBc_init_t\fP< c > \fBinit\fP, const \fBcomponent_builder_t\fP &spec)"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "std::function< void(\fBComponent\fP *)> \fBinner_redraw\fP"
.br
.ti -1c
.RI "bool \fBis_group\fP = false"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line \fB90\fP of file \fBcomponents\&.hpp\fP\&.
.SH "Member Typedef Documentation"
.PP 
.SS "typedef \fBKeyEvent::DataType\fP \fBcydui::components::Component::KeyData\fP"

.PP
Definition at line \fB268\fP of file \fBcomponents\&.hpp\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Component::Component ()"

.PP
Definition at line \fB20\fP of file \fBcomponents\&.cpp\fP\&..PP
.nf
20                     : Component([](Component*) {
21 }) {
22 }
.fi

.SS "Component::Component (std::function< void(\fBComponent\fP *)> inner)"

.PP
Definition at line \fB24\fP of file \fBcomponents\&.cpp\fP\&..PP
.nf
25   : Component(new ComponentState(), inner) {
26   (*state\&.unwrap())\->stateless_comp = true;
27 }
.fi

.SS "Component::Component (\fBComponentState\fP * state)"

.PP
Definition at line \fB29\fP of file \fBcomponents\&.cpp\fP\&..PP
.nf
30   : Component(state, [](Component*) {
31 }) {
32 }
.fi

.SS "Component::Component (\fBComponentState\fP * state, std::function< void(\fBComponent\fP *)> inner)"

.PP
Definition at line \fB34\fP of file \fBcomponents\&.cpp\fP\&..PP
.nf
37   : state(state), dim(&state\->dim) {
38   (*this\->state\&.unwrap())\->component_instance = this;
39   this\->inner_redraw = std::move(inner);
40   parent\&.set_null();
41 }
.fi

.SS "Component::~Component ()\fC [virtual]\fP"

.PP
Definition at line \fB44\fP of file \fBcomponents\&.cpp\fP\&..PP
.nf
44                       {
45   for (auto &child: children)
46     delete child;
47   children\&.clear();
48   //for (auto &child: param_children)
49   //  delete child;
50   //param_children\&.clear();
51   if (state\&.let(_(ComponentState *, {
52     it\->component_instance = nullptr;
53     return it\->stateless_comp;
54   })) or false) {
55     state\&.set_null();
56   }
57 }
.fi

.SH "Member Function Documentation"
.PP 
.SS "void Component::add (const std::vector< \fBcomponent_builder_t\fP > & ichildren, bool prepend = \fCfalse\fP) const"

.PP
Definition at line \fB66\fP of file \fBcomponents\&.cpp\fP\&..PP
.nf
68         {
69   // TODO \- Needs to be recursive when flattening groups, not just first layer
70   for (auto &item: ichildren) {
71     auto* child = item\&.build(item);
72     if (child == nullptr)
73       continue;
74     if (child\->is_group) {
75       for (auto &subitem: child\->children) {
76         if (subitem == nullptr || !subitem\->state)
77           continue;
78         subitem\->parent = (Component*) this;
79         (*subitem\->state\&.unwrap())\->win = (*state\&.unwrap())\->win;
80         if (prepend) {
81           this\->children\&.push_front(subitem);
82         } else {
83           this\->children\&.push_back(subitem);
84         }
85       }
86       child\->children\&.clear();
87       delete child;
88     } else {
89       child\->parent = (Component*) this;
90       (*child\->state\&.unwrap())\->win = (*state\&.unwrap())\->win;
91       if (prepend) {
92         this\->children\&.push_front(child);
93       } else {
94         this\->children\&.push_back(child);
95       }
96     }
97   }
98 }
.fi

.SS "template<typename c , int ID> 
.br
requires \fBComponentConcept\fP<c>\fBcomponent_builder_t\fP cydui::components::Component::create (\fBc_init_t\fP< c > init) const\fC [inline]\fP, \fC [protected]\fP"

.PP
Definition at line \fB144\fP of file \fBcomponents\&.hpp\fP\&..PP
.nf
144                                                                 {
145         return {
146           \&.x = init\&.x,
147           \&.y = init\&.y,
148           \&.w = init\&.w,
149           \&.h = init\&.h,
150           \&.build = *(state\&.let(_(ComponentState *, {
151             auto* st = (typename c::State*) (it\->children\&.contains(ID)
152               ? (it\->children[ID])
153               : (it\->children\&.add(ID, new typename c::State())));
154             st\->win = it\->win;
155             return st;
156           }))\&.let(_(typename c::State*, {
157             SET_REFERENCE it;
158             return [=](component_builder_t spec) {
159               auto* _c = new c(it, init\&.props, get_init_function(init, spec));
160               return _c;
161             };
162           }))\&.unwrap())
163         };
164       }
.fi

.SS "template<typename c , int ID, typename \fBT\fP > 
.br
requires \fBComponentConcept\fP<c>\fBcomponent_builder_t\fP cydui::components::Component::create_for (const \fBT\fP & iter, std::function< \fBc_init_t\fP< c >(const typename T::value_type &)> block) const\fC [inline]\fP, \fC [protected]\fP"

.PP
Definition at line \fB168\fP of file \fBcomponents\&.hpp\fP\&..PP
.nf
170               {
171         std::vector<typename c::State*> states = {};
172         state\&.let(_(ComponentState *, {
173           int k = 0;
174           for (auto a = iter\&.begin(); a != iter\&.end(); ++a, ++k) {
175             auto* st =
176               (typename c::State*) (it\->children\&.contains(ID, k)
177                 ? (it\->children\&.get_list(ID, k))
178                 : (it\->children\&.add_list(ID, k, new typename c::State())));
179             st\->win = it\->win;
180             states\&.push_back(st);
181           }
182         }));
183         
184         return {
185           \&.x = std::nullopt,
186           \&.y = std::nullopt,
187           \&.w = std::nullopt,
188           \&.h = std::nullopt,
189           \&.build = [iter, block, states](component_builder_t spec) {
190             int i = 0;
191             auto temp_c = Component::new_group();
192             for (auto a = iter\&.begin(); a != iter\&.end(); ++a, ++i) {
193               const c_init_t<c> init = block(*a);
194               SET_REFERENCE nullptr;
195               temp_c\->children\&.push_back(
196                 new c(states[i], init\&.props, get_init_function(init, spec))
197               );
198             }
199             return temp_c;
200           },
201         };
202       }
.fi

.SS "\fBcomponent_builder_t\fP cydui::components::Component::create_group (std::vector< \fBcomponent_builder_t\fP > _children) const\fC [inline]\fP, \fC [protected]\fP"

.PP
Definition at line \fB204\fP of file \fBcomponents\&.hpp\fP\&..PP
.nf
204                                                                                                {
205         return {
206           \&.build = [_children](const component_builder_t &) {
207             auto* group = Component::new_group();
208             group\->add(_children);
209             return group;
210           }
211         };
212       }
.fi

.SS "template<typename c > 
.br
requires \fBComponentConcept\fP<c>static std::function< void(\fBComponent\fP *)> cydui::components::Component::get_init_function (\fBc_init_t\fP< c > init, const \fBcomponent_builder_t\fP & spec)\fC [inline]\fP, \fC [static]\fP, \fC [private]\fP"

.PP
Definition at line \fB100\fP of file \fBcomponents\&.hpp\fP\&..PP
.nf
100                                                                                                                 {
101         return [init, spec](cydui::components::Component* __raw_local_) {
102           auto* local = (c*) __raw_local_;
103           
104           __raw_local_\->state\&.let(_(ComponentState *, {
105             if (spec\&.x\&.has_value())
106               it\->dim\&.x = spec\&.x\&.value();
107             else if (init\&.x\&.has_value())
108               it\->dim\&.x = init\&.x\&.value();
109             
110             if (spec\&.y\&.has_value())
111               it\->dim\&.y = spec\&.y\&.value();
112             else if (init\&.y\&.has_value())
113               it\->dim\&.y = init\&.y\&.value();
114             
115             if (spec\&.w\&.has_value()) {
116               it\->dim\&.w = spec\&.w\&.value();
117               it\->dim\&.given_w = true;
118             } else if (init\&.w\&.has_value()) {
119               it\->dim\&.w = init\&.w\&.value();
120               it\->dim\&.given_w = true;
121             }
122             if (spec\&.h\&.has_value()) {
123               it\->dim\&.h = spec\&.h\&.value();
124               it\->dim\&.given_h = true;
125             } else if (init\&.h\&.has_value()) {
126               it\->dim\&.h = init\&.h\&.value();
127               it\->dim\&.given_h = true;
128             }
129           }));
130           
131           local\->add(init\&.inner);
132           init\&.init(local);
133         };
134       }
.fi

.SS "\fBnullable\fP< \fBComponent\fP * > Component::get_parent () const"

.PP
Definition at line \fB220\fP of file \fBcomponents\&.cpp\fP\&..PP
.nf
220                                                  {
221   return parent;
222 }
.fi

.SS "bool cydui::components::Component::is_drawable () const\fC [virtual]\fP"

.PP
Definition at line \fB138\fP of file \fBcomponents\&.cpp\fP\&..PP
.nf
138                                                  {
139   return false;
140 }
.fi

.SS "\fBComponent\fP * Component::new_group ()\fC [static]\fP"

.PP
Definition at line \fB60\fP of file \fBcomponents\&.cpp\fP\&..PP
.nf
60                                 {
61   auto* c = new Component();
62   c\->is_group = true;
63   return c;
64 }
.fi

.SS "void Component::on_drag_finish (int x, int y) const\fC [virtual]\fP"

.PP
Definition at line \fB205\fP of file \fBcomponents\&.cpp\fP\&..PP
.nf
205                                                      { // NOLINT(misc\-no\-recursion)
206   parent\&.let(_(Component *, {
207     auto &p = it;
208     p\->on_drag_finish(x + dim\->x\&.val(), y + dim\->y\&.val());
209   }));
210 }
.fi

.SS "void Component::on_drag_motion (int x, int y) const\fC [virtual]\fP"

.PP
Definition at line \fB198\fP of file \fBcomponents\&.cpp\fP\&..PP
.nf
198                                                      { // NOLINT(misc\-no\-recursion)
199   parent\&.let(_(Component *, {
200     auto &p = it;
201     p\->on_drag_motion(x + dim\->x\&.val(), y + dim\->y\&.val());
202   }));
203 }
.fi

.SS "void Component::on_drag_start (int x, int y) const\fC [virtual]\fP"

.PP
Definition at line \fB191\fP of file \fBcomponents\&.cpp\fP\&..PP
.nf
191                                                     { // NOLINT(misc\-no\-recursion)
192   parent\&.let(_(Component *, {
193     auto &p = it;
194     p\->on_drag_start(x + dim\->x\&.val(), y + dim\->y\&.val());
195   }));
196 }
.fi

.SS "void Component::on_key_press (\fBKeyData\fP key) const\fC [virtual]\fP"

.PP
Definition at line \fB151\fP of file \fBcomponents\&.cpp\fP\&..PP
.nf
151                                                   { // NOLINT(misc\-no\-recursion)
152   parent\&.let(_(Component *, {
153     it\->on_key_press(key);
154   }));
155 }
.fi

.SS "void Component::on_key_release (\fBKeyData\fP key) const\fC [virtual]\fP"

.PP
Definition at line \fB157\fP of file \fBcomponents\&.cpp\fP\&..PP
.nf
157                                                     { // NOLINT(misc\-no\-recursion)
158   parent\&.let(_(Component *, {
159     it\->on_key_release(key);
160   }));
161 }
.fi

.SS "void Component::on_mouse_click (int x, int y, int button) const\fC [virtual]\fP"

.PP
Definition at line \fB170\fP of file \fBcomponents\&.cpp\fP\&..PP
.nf
170                                                                  { // NOLINT(misc\-no\-recursion)
171   parent\&.let(_(Component *, {
172     auto &p = it;
173     p\->on_mouse_click(x + dim\->x\&.val(), y + dim\->y\&.val(), button);
174   }));
175 }
.fi

.SS "void Component::on_mouse_enter (int x, int y) const\fC [virtual]\fP"

.PP
Definition at line \fB163\fP of file \fBcomponents\&.cpp\fP\&..PP
.nf
163                                                      { // NOLINT(misc\-no\-recursion)
164   parent\&.let(_(Component *, {
165     auto &p = it;
166     p\->on_mouse_enter(x + dim\->x\&.val(), y + dim\->y\&.val());
167   }));
168 }
.fi

.SS "void Component::on_mouse_exit (int x, int y) const\fC [virtual]\fP"

.PP
Definition at line \fB177\fP of file \fBcomponents\&.cpp\fP\&..PP
.nf
177                                                     { // NOLINT(misc\-no\-recursion)
178   parent\&.let(_(Component *, {
179     auto &p = it;
180     p\->on_mouse_exit(x + dim\->x\&.val(), y + dim\->y\&.val());
181   }));
182 }
.fi

.SS "void Component::on_mouse_motion (int x, int y) const\fC [virtual]\fP"

.PP
Definition at line \fB184\fP of file \fBcomponents\&.cpp\fP\&..PP
.nf
184                                                       { // NOLINT(misc\-no\-recursion)
185   parent\&.let(_(Component *, {
186     auto &p = it;
187     p\->on_mouse_motion(x + dim\->x\&.val(), y + dim\->y\&.val());
188   }));
189 }
.fi

.SS "void Component::on_redraw () const\fC [virtual]\fP"

.PP
Reimplemented in \fBVBox\fP, \fBHBox\fP, \fBProfiler\fP, and \fBThreadTimeline\fP\&.
.PP
Definition at line \fB148\fP of file \fBcomponents\&.cpp\fP\&..PP
.nf
148                                     {
149 }
.fi

.SS "void Component::on_render (\fBvg::vg_fragment_t\fP & graphics) const\fC [virtual]\fP"

.PP
Definition at line \fB145\fP of file \fBcomponents\&.cpp\fP\&..PP
.nf
145                                                               {
146 }
.fi

.SS "void Component::on_scroll (int dx, int dy) const\fC [virtual]\fP"

.PP
Definition at line \fB212\fP of file \fBcomponents\&.cpp\fP\&..PP
.nf
212                                                   { // NOLINT(misc\-no\-recursion)
213   parent\&.let(_(Component *, {
214     it\->on_scroll(dx, dy);
215   }));
216 }
.fi

.SS "void Component::redraw (\fBcydui::layout::Layout\fP * layout)"

.PP
Definition at line \fB100\fP of file \fBcomponents\&.cpp\fP\&..PP
.nf
100                                                 {
101   inner_redraw(this);
102   on_redraw();
103   
104   for (auto &child: children) {
105     child\->redraw(layout);
106   }
107   state\&.let(_(ComponentState *, {
108     it\->dragging_context = &layout\->dragging_context;
109     it\->_dirty = false;
110   }));
111 }
.fi

.SS "void Component::render (\fBcydui::compositing::compositing_node_t\fP * node) const"

.PP
Definition at line \fB113\fP of file \fBcomponents\&.cpp\fP\&..PP
.nf
113                                                                      {
114   node\->id = (unsigned long) (*this\->state\&.unwrap());
115   node\->op = {
116     \&.x = dim\->x\&.val(),
117     \&.y = dim\->y\&.val(),
118     \&.w = dim\->w\&.val(),
119     \&.h = dim\->h\&.val(),
120     \&.rot = 0\&.0, // dim\->rot\&.val(),
121     \&.scale_x = 1\&.0, // dim\->scale_x\&.val(),
122     \&.scale_y = 1\&.0, // dim\->scale_y\&.val(),
123   };
124   
125   if (is_drawable()) {
126     on_render(node\->graphics);
127   } else {
128     for (const auto &child: children) {
129       if (child) {
130         auto* c_node = new compositing::compositing_node_t();
131         node\->children\&.push_back(c_node);
132         child\->render(c_node);
133       }
134     }
135   }
136 }
.fi

.SH "Member Data Documentation"
.PP 
.SS "std::deque<\fBComponent\fP*> cydui::components::Component::children\fC [mutable]\fP"

.PP
Definition at line \fB255\fP of file \fBcomponents\&.hpp\fP\&.
.SS "\fBcydui::dimensions::component_dimensions_t\fP* cydui::components::Component::dim"

.PP
Definition at line \fB251\fP of file \fBcomponents\&.hpp\fP\&.
.SS "std::function<void(\fBComponent\fP*)> cydui::components::Component::inner_redraw\fC [private]\fP"
\fBInitial value:\fP.PP
.nf
= [](Component*) {
      }
.fi

.PP
Definition at line \fB92\fP of file \fBcomponents\&.hpp\fP\&..PP
.nf
92                                                                   {
93       };
.fi

.SS "bool cydui::components::Component::is_group = false\fC [private]\fP"

.PP
Definition at line \fB95\fP of file \fBcomponents\&.hpp\fP\&.
.SS "\fBnullable\fP<\fBComponent\fP*> cydui::components::Component::parent\fC [mutable]\fP"

.PP
Definition at line \fB249\fP of file \fBcomponents\&.hpp\fP\&.
.SS "\fBnullable\fP<\fBComponentState\fP*> cydui::components::Component::state\fC [mutable]\fP"

.PP
Definition at line \fB250\fP of file \fBcomponents\&.hpp\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for CYD-UI from the source code\&.
