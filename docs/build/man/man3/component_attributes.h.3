.TH "include/core/component_attributes.h" 3 "CYD-UI" \" -*- nroff -*-
.ad l
.nh
.SH NAME
include/core/component_attributes.h
.SH SYNOPSIS
.br
.PP
\fC#include 'dimensions\&.hpp'\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBattribute_i\fP"
.br
.ti -1c
.RI "struct \fBattr_x< E >\fP"
.br
.ti -1c
.RI "struct \fBattr_y< E >\fP"
.br
.ti -1c
.RI "struct \fBattr_w< E >\fP"
.br
.ti -1c
.RI "struct \fBattr_h< E >\fP"
.br
.ti -1c
.RI "struct \fBattr_margin_top< E >\fP"
.br
.ti -1c
.RI "struct \fBattr_margin_bottom< E >\fP"
.br
.ti -1c
.RI "struct \fBattr_margin_left< E >\fP"
.br
.ti -1c
.RI "struct \fBattr_margin_right< E >\fP"
.br
.ti -1c
.RI "struct \fBattr_padding_top< E >\fP"
.br
.ti -1c
.RI "struct \fBattr_padding_bottom< E >\fP"
.br
.ti -1c
.RI "struct \fBattr_padding_left< E >\fP"
.br
.ti -1c
.RI "struct \fBattr_padding_right< E >\fP"
.br
.ti -1c
.RI "struct \fBattr_content< E >\fP"
.br
.ti -1c
.RI "struct \fBattrs_margin< T >\fP"
.br
.ti -1c
.RI "struct \fBattrs_padding< T >\fP"
.br
.ti -1c
.RI "struct \fBattrs_dimensions< T >\fP"
.br
.ti -1c
.RI "struct \fBattrs_component< T >\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBCOMPONENT_ATTRIBUTE\fP(TYPE,  NAME,  DEFAULT)"
.br
.ti -1c
.RI "#define \fBCOMPONENT_ATTRIBUTE_W_MONITOR\fP(TYPE,  NAME,  DEFAULT)"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "using \fBcontent\fP = std::vector< \fBcydui::components::component_holder_t\fP >"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define COMPONENT_ATTRIBUTE(TYPE, NAME, DEFAULT)"
\fBValue:\fP.PP
.nf
    template<typename E>                         \\
    struct attr_##NAME: public attribute_i {     \\
      TYPE _##NAME = DEFAULT;                    \\
      ~attr_##NAME() override = default;         \\
      template<typename S = E, typename = std::enable_if_t<!std::is_void_v<S>>> \\
      inline S& NAME(auto& _##NAME##_) {   \\
        this\->_##NAME = _##NAME##_;              \\
        return *(E*)this;                        \\
      }                                          \\
      template<typename S = E, typename = std::enable_if_t<!std::is_void_v<S>>> \\
      inline S& NAME(auto&& _##NAME##_) {  \\
        this\->_##NAME = _##NAME##_;              \\
        return *(E*)this;                        \\
      }                                          \\
      template<typename S = E, typename = std::enable_if_t<std::is_void_v<S>>> \\
      inline void NAME(auto& _##NAME##_) {   \\
        this\->_##NAME = _##NAME##_;              \\
      }                                          \\
      template<typename S = E, typename = std::enable_if_t<std::is_void_v<S>>> \\
      inline void NAME(auto&& _##NAME##_) {  \\
        this\->_##NAME = _##NAME##_;              \\
      }                                          \\
    }
.fi

.PP
Definition at line \fB14\fP of file \fBcomponent_attributes\&.h\fP\&..PP
.nf
16                       : public attribute_i {     \\
17       TYPE _##NAME = DEFAULT;                    \\
18       ~attr_##NAME() override = default;         \\
19       template<typename S = E, typename = std::enable_if_t<!std::is_void_v<S>>> \\
20       inline S& NAME(auto& _##NAME##_) {   \\
21         this\->_##NAME = _##NAME##_;              \\
22         return *(E*)this;                        \\
23       }                                          \\
24       template<typename S = E, typename = std::enable_if_t<!std::is_void_v<S>>> \\
25       inline S& NAME(auto&& _##NAME##_) {  \\
26         this\->_##NAME = _##NAME##_;              \\
27         return *(E*)this;                        \\
28       }                                          \\
29       template<typename S = E, typename = std::enable_if_t<std::is_void_v<S>>> \\
30       inline void NAME(auto& _##NAME##_) {   \\
31         this\->_##NAME = _##NAME##_;              \\
32       }                                          \\
33       template<typename S = E, typename = std::enable_if_t<std::is_void_v<S>>> \\
34       inline void NAME(auto&& _##NAME##_) {  \\
35         this\->_##NAME = _##NAME##_;              \\
36       }                                          \\
37     }
.fi

.SS "#define COMPONENT_ATTRIBUTE_W_MONITOR(TYPE, NAME, DEFAULT)"
\fBValue:\fP.PP
.nf
    template<typename E>                                   \\
    struct attr_##NAME: public attribute_i {               \\
      TYPE _##NAME = DEFAULT;                              \\
      bool _##NAME##_has_changed = false;                  \\
      ~attr_##NAME() override = default;                   \\
      template<typename S = E, typename = std::enable_if_t<!std::is_void_v<S>>> \\
      inline S& NAME(auto& _##NAME##_) {                   \\
        this\->_##NAME = _##NAME##_;                        \\
        this\->_##NAME##_has_changed = true;                \\
        return *(E*)this;                                  \\
      }                                                    \\
      template<typename S = E, typename = std::enable_if_t<!std::is_void_v<S>>> \\
      inline S& NAME(auto&& _##NAME##_) {             \\
        this\->_##NAME = _##NAME##_;                        \\
        this\->_##NAME##_has_changed = true;                \\
        return *(E*)this;                                  \\
      }                                                    \\
      template<typename S = E, typename = std::enable_if_t<std::is_void_v<S>>> \\
      inline void NAME(auto& _##NAME##_) {                   \\
        this\->_##NAME = _##NAME##_;                        \\
        this\->_##NAME##_has_changed = true;                \\
      }                                                    \\
      template<typename S = E, typename = std::enable_if_t<std::is_void_v<S>>> \\
      inline void NAME(auto&& _##NAME##_) {             \\
        this\->_##NAME = _##NAME##_;                        \\
        this\->_##NAME##_has_changed = true;                \\
      }                                                    \\
    }
.fi

.PP
Definition at line \fB39\fP of file \fBcomponent_attributes\&.h\fP\&..PP
.nf
41                       : public attribute_i {               \\
42       TYPE _##NAME = DEFAULT;                              \\
43       bool _##NAME##_has_changed = false;                  \\
44       ~attr_##NAME() override = default;                   \\
45       template<typename S = E, typename = std::enable_if_t<!std::is_void_v<S>>> \\
46       inline S& NAME(auto& _##NAME##_) {                   \\
47         this\->_##NAME = _##NAME##_;                        \\
48         this\->_##NAME##_has_changed = true;                \\
49         return *(E*)this;                                  \\
50       }                                                    \\
51       template<typename S = E, typename = std::enable_if_t<!std::is_void_v<S>>> \\
52       inline S& NAME(auto&& _##NAME##_) {             \\
53         this\->_##NAME = _##NAME##_;                        \\
54         this\->_##NAME##_has_changed = true;                \\
55         return *(E*)this;                                  \\
56       }                                                    \\
57       template<typename S = E, typename = std::enable_if_t<std::is_void_v<S>>> \\
58       inline void NAME(auto& _##NAME##_) {                   \\
59         this\->_##NAME = _##NAME##_;                        \\
60         this\->_##NAME##_has_changed = true;                \\
61       }                                                    \\
62       template<typename S = E, typename = std::enable_if_t<std::is_void_v<S>>> \\
63       inline void NAME(auto&& _##NAME##_) {             \\
64         this\->_##NAME = _##NAME##_;                        \\
65         this\->_##NAME##_has_changed = true;                \\
66       }                                                    \\
67     }
.fi

.SH "Typedef Documentation"
.PP 
.SS "using \fBcontent\fP =  std::vector<\fBcydui::components::component_holder_t\fP>"

.PP
Definition at line \fB84\fP of file \fBcomponent_attributes\&.h\fP\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for CYD-UI from the source code\&.
